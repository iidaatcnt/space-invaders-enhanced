<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>スペースインベーダー - モバイル版</title>
  <style>
    :root { --bg:#0b0f1a; --fg:#f2f5ff; --accent:#42ff88; --muted:#8aa0ff; }
    html,body{height:100%;}
    body{margin:0; background:radial-gradient(1200px 600px at 50% -200px,#101426 0%, #0b0f1a 60%, #070a12 100%); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "メイリオ", Meiryo, "Apple Color Emoji", "Segoe UI Emoji";}
    #wrap{position:relative; width:100vw; height:100vh; margin:0; display:flex; flex-direction:column; justify-content:center; align-items:center;}
    canvas{width:100%; max-width:960px; height:auto; max-height:calc(100vh - 140px); display:block; background:transparent; touch-action:none;}
    .hud{position:absolute; inset:0; pointer-events:none;}
    .row{display:flex; justify-content:space-between; align-items:center; gap:8px; padding:10px 12px; font-weight:700; letter-spacing:.02em; text-shadow:0 2px 12px rgba(0,0,0,.45)}
    .score, .lives, .level{font-variant-numeric:tabular-nums;}
    .pill{display:inline-block; padding:.25rem .5rem; border-radius:9999px; background:rgba(255,255,255,.06); box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);}
    .center{position:absolute; inset:0; display:grid; place-items:center;}
    .panel{pointer-events:auto; text-align:center; background:rgba(6,10,18,.74); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:22px 24px; backdrop-filter: blur(8px); box-shadow:0 10px 40px rgba(0,0,0,.35);}
    .panel h1{margin:.1rem 0 0.35rem; font-size:clamp(24px, 5vw, 40px); letter-spacing:.04em;}
    .panel p{margin:.4rem 0; color:#c8d0ff; font-size:clamp(12px, 2.8vw, 16px)}
    .kbd{display:inline-block; min-width:1.6em; text-align:center; padding:.18rem .45rem; border-radius:8px; background:#0d1322; border:1px solid rgba(255,255,255,.14); box-shadow: inset 0 -2px 0 rgba(255,255,255,.06), 0 4px 16px rgba(0,0,0,.35);}
    .btn{pointer-events:auto; cursor:pointer; margin-top:.6rem; display:inline-block; background:linear-gradient(180deg,#2ef29f,#19ce85); color:#02120a; font-weight:800; border:none; padding:.6rem 1rem; border-radius:12px; box-shadow:0 10px 30px rgba(23, 232, 142, .45);}
    .tiny{font-size:12px; opacity:.85}
    .hidden{display:none}
    .mobile-only{display:none}
    @media (pointer:coarse), (max-width:768px){
      .mobile-only{display:block}
      .desktop-only{display:none}
    }
    
    /* Mobile controls - Always visible on touch devices */
    .mobile-controls{display:none; position:fixed; bottom:10px; left:0; right:0; height:140px; pointer-events:auto; user-select:none; -webkit-user-select:none; z-index:100;}
    @media (pointer:coarse), (max-width:768px){
      .mobile-controls{display:grid; grid-template-columns:1fr 2fr 1fr; gap:10px; padding:0 10px; align-items:center;}
      .control-group{display:flex; gap:8px; justify-content:center;}
      .mobile-btn{width:70px; height:70px; border-radius:15px; background:rgba(255,255,255,0.15); border:2px solid rgba(255,255,255,0.3); display:grid; place-items:center; font-size:28px; color:var(--fg); touch-action:none; transition:all 0.1s;}
      .mobile-btn:active{background:rgba(255,255,255,0.25); transform:scale(0.92); box-shadow:0 0 20px rgba(255,255,255,0.3);}
      .mobile-fire{width:100px; height:100px; background:linear-gradient(135deg, rgba(66,255,136,0.3), rgba(66,255,136,0.15)); border-color:var(--accent); font-size:40px;}
      .mobile-special{width:60px; height:60px; background:linear-gradient(135deg, rgba(255,66,66,0.3), rgba(255,66,66,0.15)); border-color:#ff4444; font-size:20px;}
      .mobile-pause{width:50px; height:50px; font-size:20px;}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="600" aria-label="インベーダーゲーム"></canvas>
    <div class="hud" aria-hidden="true">
      <div class="row">
        <div class="score">SCORE: <span id="score">0000</span></div>
        <div class="pill">HIGH: <span id="hiscore">0000</span></div>
        <div class="level">LEVEL: <span id="level">1</span></div>
        <div class="lives">LIVES: <span id="lives">5</span></div>
      </div>
      <div class="center">
        <div id="screen-title" class="panel">
          <h1>SPACE INVADERS</h1>
          <h1 style="font-size:20px; color:#42ff88; margin-top:-10px;">モバイル版</h1>
          <div class="mobile-only" style="margin:15px 0;">
            <p style="font-size:18px; color:#42c3ff;">📱 タッチ操作</p>
            <p>◀▶ 移動 | 🚀 発射 | ⚡ 必殺技</p>
          </div>
          <div class="desktop-only">
            <p><span class="kbd">←</span> / <span class="kbd">→</span> または <span class="kbd">A</span> / <span class="kbd">D</span>：移動　　<span class="kbd">SPACE</span>：ショット</p>
            <p><span class="kbd">P</span>：一時停止　　<span class="kbd">R</span>：やり直し</p>
          </div>
          <p class="tiny">時々、上空に<span style="color:var(--accent); font-weight:800;">UFO</span>が出現！ 撃墜で高得点！</p>
          <p class="tiny"><span style="color:#ff9d42;">パワーアップ</span>を集めて強くなろう！</p>
          <button id="btn-start" class="btn">ゲーム開始</button>
          <button id="btn-tutorial" class="btn" style="background:linear-gradient(180deg,#42c3ff,#2a9dd6); margin-left:10px;">遊び方</button>
        </div>
        <div id="screen-gameover" class="panel hidden">
          <h1>GAME OVER</h1>
          <p>スコア：<span id="final-score">0</span>　ハイスコア：<span id="final-hiscore">0</span></p>
          <button id="btn-restart" class="btn">もう一度（R）</button>
        </div>
        <div id="screen-paused" class="panel hidden">
          <h1>一時停止中</h1>
          <p style="font-size: 18px; margin: 15px 0;">ゲームが一時停止されています</p>
          <p class="desktop-only">再開するには <span class="kbd">P</span> キーを押してください</p>
          <p class="mobile-only">⏸️ ボタンをタップして再開</p>
          <p class="tiny" style="margin-top: 20px;">または <span class="kbd">ESC</span> でタイトルに戻る</p>
        </div>
        <div id="screen-tutorial" class="panel hidden">
          <h1>🎮 遊び方</h1>
          <div style="text-align:left; max-width:400px; margin:0 auto;">
            <p style="margin:10px 0;"><strong>目標:</strong> すべての侵略者を倒そう！</p>
            <p style="margin:10px 0;"><strong>操作:</strong></p>
            <ul style="margin:10px 0; padding-left:20px;">
              <li>◀▶ で左右に移動</li>
              <li>🚀 でミサイル発射</li>
              <li>⚡ で必殺技（1回のみ）</li>
            </ul>
            <p style="margin:10px 0;"><strong>パワーアップ:</strong></p>
            <ul style="margin:10px 0; padding-left:20px;">
              <li><span style="color:#ff9d42;">🔥</span> 連射速度アップ</li>
              <li><span style="color:#42c3ff;">💫</span> 3方向ショット</li>
              <li><span style="color:#42ff88;">🛡️</span> シールド修復</li>
            </ul>
            <p style="margin:10px 0;"><strong>ヒント:</strong> UFOを狙って高得点！</p>
          </div>
          <button id="btn-tutorial-close" class="btn">閉じる</button>
        </div>
      </div>
    </div>
    <!-- Enhanced Mobile controls -->
    <div class="mobile-controls">
      <div class="control-group">
        <button class="mobile-btn" id="mobile-left" aria-label="左移動">◀</button>
        <button class="mobile-btn" id="mobile-right" aria-label="右移動">▶</button>
      </div>
      <div class="control-group" style="justify-content:center;">
        <button class="mobile-btn mobile-fire" id="mobile-fire" aria-label="発射">🚀</button>
      </div>
      <div class="control-group">
        <button class="mobile-btn mobile-special" id="mobile-special" aria-label="必殺技">⚡</button>
        <button class="mobile-btn mobile-pause" id="mobile-pause" aria-label="一時停止">⏸️</button>
      </div>
    </div>
  </div>

  <script>
  (()=>{
    // ===== Utility =====
    const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
    const rand=(a,b)=>Math.random()*(b-a)+a;
    const choice=arr=>arr[(Math.random()*arr.length)|0];

    // High DPI scaling
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // scale drawing to CSS pixels
    }
    new ResizeObserver(resizeCanvas).observe(canvas);
    resizeCanvas();

    // ===== Game State =====
    const W=960, H=600;
    canvas.style.aspectRatio = `${W}/${H}`;
    
    // Mobile optimization - reduce particles on mobile
    const MAX_PARTICLES = isMobile ? 200 : 500;
    const PARTICLE_COUNT = isMobile ? 8 : 12;

    let state='title';
    let score=0, hiscore= Number(localStorage.getItem('inv_hi')||0), level=1, lives=5;
    
    // Student progress tracking
    let sessionStats = {
      startTime: Date.now(),
      enemiesDestroyed: 0,
      powerUpsCollected: 0,
      highestLevel: 1
    };
    let combo = 0;
    let comboTimer = 0;
    let waveTransition = false;
    let waveTransitionTimer = 0;
    let isBossLevel = false;
    
    // Achievement system
    let achievements = JSON.parse(localStorage.getItem('space_invaders_achievements') || '{}');
    let sessionStats = {
      enemiesKilled: 0,
      maxCombo: 0,
      bossesDefeated: 0,
      powerUpsCollected: 0
    };

    // HUD hooks
    const $ = sel => document.querySelector(sel);
    const scrEl = $('#score');
    const hiEl  = $('#hiscore');
    const lvEl  = $('#level');
    const livesEl = $('#lives');
    const titleScreen = $('#screen-title');
    const overScreen = $('#screen-gameover');
    const pausedScreen = $('#screen-paused');

    function updateHUD(){
      scrEl.textContent = score.toString().padStart(4,'0');
      hiEl.textContent  = hiscore.toString().padStart(4,'0');
      lvEl.textContent  = level;
      livesEl.textContent = lives;
    }
    
    // Achievement checking
    const achievementList = {
      'first_kill': { name: '初撃破', desc: '初めて敵を倒した', icon: '🎯' },
      'combo_master': { name: 'コンボマスター', desc: '10連続コンボを達成', icon: '🔥' },
      'boss_slayer': { name: 'ボス討伐者', desc: 'ボスを倒した', icon: '👑' },
      'power_collector': { name: 'パワーアップ収集家', desc: 'パワーアップを10個取得', icon: '💎' },
      'survivor': { name: 'サバイバー', desc: 'レベル10に到達', icon: '🛡️' },
      'high_scorer': { name: 'ハイスコアラー', desc: '10000点を獲得', icon: '⭐' }
    };
    
    function checkAchievement(key) {
      if(achievements[key]) return; // Already unlocked
      
      let unlock = false;
      switch(key) {
        case 'first_kill':
          unlock = sessionStats.enemiesKilled >= 1;
          break;
        case 'combo_master':
          unlock = sessionStats.maxCombo >= 10;
          break;
        case 'boss_slayer':
          unlock = sessionStats.bossesDefeated >= 1;
          break;
        case 'power_collector':
          unlock = sessionStats.powerUpsCollected >= 10;
          break;
        case 'survivor':
          unlock = level >= 10;
          break;
        case 'high_scorer':
          unlock = score >= 10000;
          break;
      }
      
      if(unlock) {
        achievements[key] = true;
        localStorage.setItem('space_invaders_achievements', JSON.stringify(achievements));
        const ach = achievementList[key];
        floatingTexts.push(new FloatingText(`🏆 ${ach.name}`, W/2, H/2 - 50));
        beep('sawtooth', 800, .15, .04);
      }
    }
    
    function checkAllAchievements() {
      Object.keys(achievementList).forEach(checkAchievement);
    }

    // ===== Input =====
    const keys = new Set();
    const down = e=>{
      keys.add(e.code);
      if(state==='title' && (e.code==='Enter' || e.code==='Space')) startGame();
      if(e.code==='KeyP') togglePause();
      if(e.code==='KeyR') restart();
      if(e.code==='Escape' && state==='paused') {
        state='title'; 
        hideAllPanels(); 
        titleScreen.classList.remove('hidden');
        stopBGM();
        if(window.nextLevelTimeout) {
          clearTimeout(window.nextLevelTimeout);
          window.nextLevelTimeout = null;
        }
      }
    };
    const up = e=>{ keys.delete(e.code); };
    window.addEventListener('keydown', down);
    window.addEventListener('keyup', up);
    
    // Enhanced Mobile controls
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                     ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    
    // Always enable mobile controls on touch devices
    if(isMobile || window.innerWidth <= 768){
      const mobileLeft = document.getElementById('mobile-left');
      const mobileRight = document.getElementById('mobile-right');
      const mobileFire = document.getElementById('mobile-fire');
      const mobileSpecial = document.getElementById('mobile-special');
      const mobilePause = document.getElementById('mobile-pause');
      
      // Touch controls with vibration feedback
      const handleTouch = (el, code, vibration = 10) => {
        el.addEventListener('touchstart', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Vibration feedback if supported
          if('vibrate' in navigator){
            navigator.vibrate(vibration);
          }
          
          // Visual feedback
          el.classList.add('active');
          keys.add(code);
        });
        
        el.addEventListener('touchend', (e) => {
          e.preventDefault();
          e.stopPropagation();
          el.classList.remove('active');
          keys.delete(code);
        });
        
        // Handle touch cancel
        el.addEventListener('touchcancel', (e) => {
          e.preventDefault();
          el.classList.remove('active');
          keys.delete(code);
        });
      };
      
      // Movement controls
      handleTouch(mobileLeft, 'ArrowLeft', 5);
      handleTouch(mobileRight, 'ArrowRight', 5);
      
      // Fire button
      handleTouch(mobileFire, 'Space', 15);
      
      // Special attack button
      if(mobileSpecial){
        mobileSpecial.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if('vibrate' in navigator) navigator.vibrate(30);
          useSpecial();
        });
      }
      
      // Pause button
      if(mobilePause){
        mobilePause.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if('vibrate' in navigator) navigator.vibrate(20);
          togglePause();
        });
      }
      
      // Prevent double-tap zoom on all buttons
      document.querySelectorAll('.mobile-btn').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
        });
      });
    }

    // ===== Audio =====
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audio = new AudioCtx();
    let muted = false;
    let bgMusicPlaying = false;
    let currentBgMusic = null;
    
    function beep(type='square', freq=440, dur=0.06, gain=0.015){
      if(muted || audio.state!=='running') return;
      const t0 = audio.currentTime;
      const o = audio.createOscillator();
      const g = audio.createGain();
      o.type = type; o.frequency.value=freq;
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g).connect(audio.destination);
      o.start(t0); o.stop(t0+dur);
    }
    
    // Simple background music using oscillators
    function playBGM(type = 'normal'){
      if(muted || audio.state !== 'running' || bgMusicPlaying) return;
      
      bgMusicPlaying = true;
      const melody = type === 'boss' ? 
        [220, 196, 174, 196, 220, 196, 174, 164] : // Boss theme
        [330, 294, 262, 294, 330, 294, 262, 247]; // Normal theme
      
      let noteIndex = 0;
      const playNote = () => {
        if(!bgMusicPlaying || state === 'gameover' || state === 'title') return;
        
        try {
          const freq = melody[noteIndex % melody.length];
          const osc = audio.createOscillator();
          const gain = audio.createGain();
          
          osc.type = 'square';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0.003, audio.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.0001, audio.currentTime + 0.4);
          
          osc.connect(gain).connect(audio.destination);
          osc.start();
          osc.stop(audio.currentTime + 0.4);
          
          noteIndex++;
          if(bgMusicPlaying) {
            currentBgMusic = setTimeout(playNote, 500);
          }
        } catch(e) {
          console.warn('BGM playback error:', e);
          stopBGM();
        }
      };
      
      playNote();
    }
    
    function stopBGM(){
      bgMusicPlaying = false;
      if(currentBgMusic) {
        clearTimeout(currentBgMusic);
        currentBgMusic = null;
      }
    }
    
    window.addEventListener('pointerdown', ()=>{ if(audio.state!=='running') audio.resume(); }, {once:true});

    // ===== Entities =====
    class Bullet{
      constructor(x,y,vy,from,w=3,h=10){this.x=x; this.y=y; this.vy=vy; this.w=w; this.h=h; this.from=from; this.dead=false; this.vx=0;}
      update(dt){ 
        this.x += this.vx*dt;
        this.y += this.vy*dt; 
        if(this.y<-40||this.y>H+40||this.x<-40||this.x>W+40) this.dead=true; 
      }
      draw(){ ctx.fillStyle = this.from==='player'? '#42ff88' : '#ff8a8a'; ctx.fillRect(this.x-this.w/2, this.y-this.h/2, this.w, this.h); }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    class Player{
      constructor(){ 
        this.x=W/2; this.y=H-60; this.w=40; this.h=22; this.speed=320; this.cool=0; 
        this.powerUp = null;
        this.powerUpTime = 0;
        this.invulnerable = 0; // Invulnerability time after hit
      }
      update(dt){
        const left = keys.has('ArrowLeft')||keys.has('KeyA');
        const right = keys.has('ArrowRight')||keys.has('KeyD');
        let ax = (right?1:0) - (left?1:0);
        this.x += ax * this.speed * dt;
        this.x = clamp(this.x, 24, W-24);
        this.cool -= dt;
        
        // Invulnerability timer
        if(this.invulnerable > 0) {
          this.invulnerable -= dt;
        }
        
        // Power-up timer
        if(this.powerUp && this.powerUpTime > 0){
          this.powerUpTime -= dt;
          if(this.powerUpTime <= 0){
            this.powerUp = null;
            floatingTexts.push(new FloatingText('Power-up expired', this.x, this.y - 40));
          }
        }
        
        // Shooting with power-ups
        const maxBullets = this.powerUp === 'rapid' ? 5 : 2;
        const cooldown = this.powerUp === 'rapid' ? 0.06 : 0.12;
        
        if(keys.has('Space') && this.cool<=0 && bullets.filter(b=>b.from==='player').length<maxBullets){
          if(this.powerUp === 'multi'){
            // Triple shot
            bullets.push(new Bullet(this.x, this.y-18, -480, 'player'));
            bullets.push(new Bullet(this.x-12, this.y-18, -480, 'player'));
            bullets.push(new Bullet(this.x+12, this.y-18, -480, 'player'));
          } else {
            bullets.push(new Bullet(this.x, this.y-18, -480, 'player'));
          }
          this.cool = cooldown;
          beep('square', 880, .06, .02);
        }
      }
      draw(){
        ctx.save(); ctx.translate(this.x, this.y);
        
        // Invulnerability flashing
        if(this.invulnerable > 0 && Math.sin(Date.now() * 0.02) > 0) {
          ctx.globalAlpha = 0.5;
        }
        
        // Power-up aura
        if(this.powerUp){
          ctx.save();
          const auraColor = this.powerUp === 'rapid' ? '#ff9d42' : 
                           this.powerUp === 'multi' ? '#42c3ff' : '#42ff88';
          ctx.strokeStyle = auraColor;
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
          ctx.strokeRect(-24, -12, 48, 26);
          ctx.restore();
        }
        
        ctx.fillStyle = '#c7f7ff';
        ctx.fillRect(-20, 6, 40, 6);
        ctx.fillRect(-12, 0, 24, 8);
        ctx.fillRect(-4, -8, 8, 16);
        ctx.restore();
      }
      rect(){ return {x:this.x-20, y:this.y-8, w:40, h:22}; }
    }


    class Invader{ 
      constructor(x,y,row){ 
        this.x=x; this.y=y; this.w=30; this.h=22; this.row=row; this.alive=true; this.anim=0; 
        this.value= [30,30,20,20,10][row] || 10;
        this.type = 'normal';
        this.zigzagOffset = 0;
        this.speedMultiplier = 1;
        
        // Special invader types for higher levels
        if(level >= 3 && Math.random() < 0.15){
          this.type = 'zigzag';
          this.value *= 2;
        } else if(level >= 5 && Math.random() < 0.1){
          this.type = 'fast';
          this.speedMultiplier = 2;
          this.value *= 1.5;
        }
      }
      
      update(dt){
        if(!this.alive) return;
        this.anim += 0.08;
        
        if(this.type === 'zigzag'){
          this.zigzagOffset += dt * 3;
          this.y += Math.sin(this.zigzagOffset) * 0.5;
        }
      }
      
      draw(){ 
        if(!this.alive) return; 
        ctx.save(); 
        ctx.translate(this.x, this.y); 
        const t=this.anim; 
        
        let color = ['#8aa0ff','#8aa0ff','#66e6ff','#66e6ff','#98ffcc'][this.row]||'#98ffcc';
        if(this.type === 'zigzag') color = '#ff9d42';
        if(this.type === 'fast') color = '#ff4242';
        
        ctx.fillStyle = color;
        const up = Math.sin(t)>0;
        const w=this.w, h=this.h;
        ctx.fillRect(-w/2, -h/2, w, 6);
        ctx.fillRect(-w/2+ (up?4:2), -h/2+6, w-(up?8:4), 6);
        ctx.fillRect(-w/2+ (up?10:8), -h/2+12, w-(up?20:16), 6);
        
        // Special type indicators
        if(this.type === 'zigzag'){
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(-2, -2, 4, 4);
        } else if(this.type === 'fast'){
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(-6, -4, 3, 2);
          ctx.fillRect(3, -4, 3, 2);
        }
        
        ctx.restore(); 
      }
      
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    class Shield{ 
      constructor(x,y){ 
        this.x=x; this.y=y; this.cell=8; this.cols=12; this.rows=6; 
        // Create inverted U shape - hollow in the middle bottom
        this.grid=Array.from({length:this.rows},()=>Array(this.cols).fill(0));
        
        // Build inverted U shape
        for(let r=0; r<this.rows; r++){
          for(let c=0; c<this.cols; c++){
            // Top part - full width
            if(r < 2) {
              this.grid[r][c] = 1; // Less HP for easier destruction
            }
            // Middle part - sides only
            else if(r < 4) {
              if(c < 3 || c > 8) {
                this.grid[r][c] = 1;
              }
            }
            // Bottom part - just the edges
            else {
              if(c < 2 || c > 9) {
                this.grid[r][c] = 1;
              }
            }
          }
        }
      }
      
      hit(px,py){ 
        const lx = Math.floor((px - (this.x - this.cols*this.cell/2))/this.cell); 
        const ly = Math.floor((py - (this.y - this.rows*this.cell/2))/this.cell); 
        if(lx<0||ly<0||lx>=this.cols||ly>=this.rows) return false; 
        if(this.grid[ly][lx]>0){ 
          this.grid[ly][lx]--; 
          return true; 
        } 
        return false; 
      }
      
      draw(){ 
        ctx.save(); 
        ctx.translate(this.x - this.cols*this.cell/2, this.y - this.rows*this.cell/2); 
        for(let r=0;r<this.rows;r++) {
          for(let c=0;c<this.cols;c++){ 
            const hp=this.grid[r][c]; 
            if(hp<=0) continue; 
            ctx.globalAlpha = hp===1 ? 1 : 0.7; // Only 1 HP now
            ctx.fillStyle='#7bffb9'; 
            ctx.fillRect(c*this.cell, r*this.cell, this.cell-1, this.cell-1);
          }
        } 
        ctx.globalAlpha=1; 
        ctx.restore(); 
      }
    }

    class UFO{ 
      constructor(){ 
        this.w=50; this.h=22; this.y=72; 
        this.x = Math.random()<0.5? -60 : W+60; 
        this.vx = this.x<0? rand(110,160) : -rand(110,160); 
        this.alive=true; 
        this.points= choice([50,100,150,300]); 
        this.tremoloTimer = null;
        this.tremoloPlaying = false;
      }
      
      update(dt){ 
        this.x += this.vx*dt; 
        
        // Play tremolo sound while UFO is on screen
        if(this.x > -50 && this.x < W+50 && !this.tremoloPlaying) {
          this.playTremolo();
          this.tremoloPlaying = true;
        }
        
        // Stop tremolo when UFO leaves screen
        if((this.x < -60 || this.x > W+60) && this.tremoloPlaying) {
          this.stopTremolo();
          this.tremoloPlaying = false;
        }
        
        if(this.x<-100||this.x>W+100) {
          this.alive=false;
          this.stopTremolo();
        }
      }
      
      playTremolo(){
        if(muted || audio.state !== 'running' || state === 'paused') return;
        
        const playTremoloNote = () => {
          if(!this.alive || this.x < -60 || this.x > W+60 || !this.tremoloPlaying || state === 'paused') {
            this.stopTremolo();
            return;
          }
          
          try {
            beep('sine', 1200 + Math.sin(Date.now() * 0.01) * 200, .06, .008);
            this.tremoloTimer = setTimeout(playTremoloNote, 100);
          } catch(e) {
            console.warn('UFO tremolo error:', e);
          }
        };
        
        playTremoloNote();
      }
      
      stopTremolo(){
        if(this.tremoloTimer) {
          clearTimeout(this.tremoloTimer);
          this.tremoloTimer = null;
        }
        this.tremoloPlaying = false;
      }
      
      draw(){ 
        if(!this.alive) return; 
        ctx.save(); 
        ctx.translate(this.x, this.y); 
        ctx.fillStyle='#ff6d7a'; 
        ctx.fillRect(-24,-6,48,12); 
        ctx.fillRect(-16,-10,32,8); 
        ctx.fillStyle='#ffd1d6'; 
        ctx.fillRect(-6,-14,12,6); 
        ctx.restore(); 
      }
      
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }
    
    // Boss class
    class Boss{
      constructor(){
        this.x = W/2;
        this.y = 100;
        this.w = 120;
        this.h = 60;
        this.hp = 20 + level * 2;
        this.maxHp = this.hp;
        this.alive = true;
        this.moveTimer = 0;
        this.targetX = W/2;
        this.fireTimer = 0;
        this.phase = 1;
      }
      
      update(dt){
        if(!this.alive) return;
        
        // Movement pattern
        this.moveTimer += dt;
        if(this.moveTimer > 2){
          this.targetX = rand(150, W-150);
          this.moveTimer = 0;
        }
        
        // Smooth movement to target
        const dx = this.targetX - this.x;
        this.x += dx * dt * 2;
        
        // Boss shooting
        this.fireTimer -= dt;
        if(this.fireTimer <= 0){
          // Fire pattern based on phase
          if(this.phase === 1){
            // Single powerful shot
            enemyBullets.push(new Bullet(this.x, this.y + 30, 250, 'enemy', 5, 15));
          } else if(this.phase === 2){
            // Triple shot
            for(let i = -1; i <= 1; i++){
              enemyBullets.push(new Bullet(this.x + i*30, this.y + 30, 280, 'enemy'));
            }
          } else {
            // Spread shot
            for(let i = -2; i <= 2; i++){
              const angle = i * 0.2;
              const vx = Math.sin(angle) * 200;
              const vy = Math.cos(angle) * 200 + 100;
              const b = new Bullet(this.x, this.y + 30, vy, 'enemy');
              b.vx = vx;
              enemyBullets.push(b);
            }
          }
          beep('sine', 150, .08, .02);
          this.fireTimer = clamp(1.5 - this.phase * 0.3, 0.5, 1.5);
        }
        
        // Phase change based on HP
        if(this.hp <= this.maxHp * 0.66 && this.phase === 1) this.phase = 2;
        if(this.hp <= this.maxHp * 0.33 && this.phase === 2) this.phase = 3;
      }
      
      draw(){
        if(!this.alive) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Boss body with phase-based color
        const color = this.phase === 1 ? '#ff4444' : 
                     this.phase === 2 ? '#ff8844' : '#ffaa44';
        ctx.fillStyle = color;
        
        // Main body
        ctx.fillRect(-60, -20, 120, 40);
        ctx.fillRect(-50, -30, 100, 60);
        ctx.fillRect(-40, -35, 80, 70);
        
        // Eyes
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-30, -10, 10, 10);
        ctx.fillRect(20, -10, 10, 10);
        
        // HP bar
        ctx.fillStyle = 'rgba(255,0,0,0.5)';
        ctx.fillRect(-60, -50, 120, 8);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(-60, -50, 120 * (this.hp / this.maxHp), 8);
        
        ctx.restore();
      }
      
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
      
      hit(){
        this.hp--;
        if(this.hp <= 0){
          this.alive = false;
          // Big explosion
          for(let i = 0; i < 50; i++){
            particles.push(new Particle(this.x + rand(-60, 60), this.y + rand(-30, 30), '#ff4444'));
          }
          // Big points
          score += 1000 * level;
          floatingTexts.push(new FloatingText(`BOSS DEFEATED! +${1000 * level}`, this.x, this.y));
          beep('sawtooth', 100, .3, .05);
        }
      }
    }

    // Power-up class
    class PowerUp{
      constructor(x, y, type){
        this.x = x;
        this.y = y;
        this.w = 24;
        this.h = 24;
        this.type = type; // 'rapid', 'multi', 'shield'
        this.vy = 60;
        this.dead = false;
        this.pulse = 0;
      }
      update(dt){
        this.y += this.vy * dt;
        this.pulse += dt * 5;
        if(this.y > H + 30) this.dead = true;
      }
      draw(){
        ctx.save();
        ctx.translate(this.x, this.y);
        const scale = 1 + Math.sin(this.pulse) * 0.1;
        ctx.scale(scale, scale);
        
        // Draw power-up icon based on type
        if(this.type === 'rapid'){
          ctx.fillStyle = '#ff9d42';
          ctx.fillRect(-10, -4, 4, 8);
          ctx.fillRect(-2, -4, 4, 8);
          ctx.fillRect(6, -4, 4, 8);
        } else if(this.type === 'multi'){
          ctx.fillStyle = '#42c3ff';
          ctx.fillRect(-8, -8, 3, 16);
          ctx.fillRect(-1.5, -8, 3, 16);
          ctx.fillRect(5, -8, 3, 16);
        } else if(this.type === 'shield'){
          ctx.fillStyle = '#42ff88';
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.lineTo(-10, -3);
          ctx.lineTo(-10, 6);
          ctx.lineTo(0, 10);
          ctx.lineTo(10, 6);
          ctx.lineTo(10, -3);
          ctx.closePath();
          ctx.fill();
        }
        
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = ctx.fillStyle;
        ctx.fill();
        
        ctx.restore();
      }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    // ===== World containers =====
    let player; let invaders=[]; let bullets=[]; let enemyBullets=[]; let shields=[]; let ufo=null; let invDir=1; let invSpeed=32; let invStepDown=18; let fireTimer=0; let ufoTimer=rand(12,24);
    let powerUps = [];
    let powerUpTimer = rand(8, 15);
    let boss = null;

    function setupLevel(){
      invaders.length=0; bullets.length=0; enemyBullets.length=0; 
      // Stop UFO tremolo before clearing UFO
      if(ufo) ufo.stopTremolo();
      ufo=null; boss=null;
      // Reduced enemy count: 8x4 instead of 11x5 for more casual gameplay
      const cols=8, rows=4; const startX=180, gapX=64, startY=120, gapY=40;
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        invaders.push(new Invader(startX + c*gapX, startY + r*gapY, r));
      }
      invDir=1; invSpeed= 28 + (level-1)*4; // レベルで少し速く
      const y=H-140; shields=[ new Shield(W*0.2,y), new Shield(W*0.5,y), new Shield(W*0.8,y) ];
    }
    
    function setupBossLevel(){
      invaders.length=0; bullets.length=0; enemyBullets.length=0; 
      // Stop UFO tremolo before clearing UFO
      if(ufo) ufo.stopTremolo();
      ufo=null;
      boss = new Boss();
      // Fewer shields for boss battle
      const y=H-140; shields=[ new Shield(W*0.3,y), new Shield(W*0.7,y) ];
      floatingTexts.push(new FloatingText('BOSS BATTLE!', W/2, H/2));
    }

    function startGame(){
      // Clear any existing timeouts first
      if(window.nextLevelTimeout) {
        clearTimeout(window.nextLevelTimeout);
        window.nextLevelTimeout = null;
      }
      
      state='playing'; score=0; level=1; lives=5; // More lives for casual play
      combo = 0; comboTimer = 0; // Reset combo
      waveTransition = false; waveTransitionTimer = 0; // Reset transition
      
      // Reset session stats
      sessionStats = {
        startTime: Date.now(),
        enemiesDestroyed: 0,
        enemiesKilled: 0, // backward compat
        maxCombo: 0,
        bossesDefeated: 0,
        powerUpsCollected: 0,
        highestLevel: 1
      };
      
      player = new Player(); setupLevel(); updateHUD(); hideAllPanels();
      if(audio.state!=='running') audio.resume();
      stopBGM();
      setTimeout(() => {
        if(state === 'playing') playBGM('normal');
      }, 500);
    }

    function nextLevel(){ 
      level++;
      sessionStats.highestLevel = Math.max(sessionStats.highestLevel, level); 
      // Start wave transition
      waveTransition = true;
      waveTransitionTimer = 2.5;
      state = 'transition';
      
      // Check for boss level (every 5 levels)
      isBossLevel = (level % 5 === 0);
      
      // Clear any existing timeouts to prevent multiple calls
      if(window.nextLevelTimeout) clearTimeout(window.nextLevelTimeout);
      
      window.nextLevelTimeout = setTimeout(() => {
        // Additional safety check
        if(state !== 'transition') return;
        
        invSpeed += 6; 
        if(isBossLevel) {
          setupBossLevel();
          stopBGM();
          setTimeout(() => {
            if(state === 'playing') playBGM('boss');
          }, 500);
        } else {
          setupLevel();
          stopBGM();
          setTimeout(() => {
            if(state === 'playing') playBGM('normal');
          }, 500);
        }
        updateHUD();
        state = 'playing';
        waveTransition = false;
        window.nextLevelTimeout = null;
      }, 2500);
    }

    function restart(){ 
      state='title'; hideAllPanels(); titleScreen.classList.remove('hidden'); 
      stopBGM();
      // Clear any pending timeouts
      if(window.nextLevelTimeout) {
        clearTimeout(window.nextLevelTimeout);
        window.nextLevelTimeout = null;
      }
    }

    function gameOver(){
      state='gameover'; hiscore = Math.max(hiscore, score); localStorage.setItem('inv_hi', String(hiscore)); updateHUD();
      
      // Save session stats for teacher review
      const playTime = Math.floor((Date.now() - sessionStats.startTime) / 1000);
      console.log('🎮 Session Stats for Teacher Review:', {
        playTime: `${Math.floor(playTime/60)}m ${playTime%60}s`,
        score,
        highestLevel: sessionStats.highestLevel,
        enemiesDestroyed: sessionStats.enemiesDestroyed,
        powerUpsCollected: sessionStats.powerUpsCollected,
        bossesDefeated: sessionStats.bossesDefeated || 0
      });
      
      document.getElementById('final-score').textContent = String(score);
      document.getElementById('final-hiscore').textContent = String(hiscore);
      hideAllPanels(); overScreen.classList.remove('hidden');
      stopBGM();
      // Clear any pending timeouts
      if(window.nextLevelTimeout) {
        clearTimeout(window.nextLevelTimeout);
        window.nextLevelTimeout = null;
      }
    }

    function togglePause(){ 
      if(state==='playing'){ 
        state='paused'; 
        pausedScreen.classList.remove('hidden'); 
        stopBGM(); // Stop all background music during pause
        // Stop UFO tremolo if playing
        if(ufo) {
          ufo.stopTremolo();
        }
      } else if(state==='paused'){ 
        state='playing'; 
        pausedScreen.classList.add('hidden'); 
        // Resume BGM
        setTimeout(() => {
          if(state === 'playing') {
            if(boss) {
              playBGM('boss');
            } else {
              playBGM('normal');
            }
            // Resume UFO tremolo if UFO exists
            if(ufo && ufo.x > -50 && ufo.x < W+50) {
              ufo.tremoloPlaying = false; // Reset flag so it can restart
              ufo.playTremolo();
              ufo.tremoloPlaying = true;
            }
          }
        }, 100);
      } 
    }

    function hideAllPanels(){ titleScreen.classList.add('hidden'); overScreen.classList.add('hidden'); pausedScreen.classList.add('hidden'); }

    // ===== Collision & helpers =====
    function overlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    function bottomInvadersByColumn(){
      const byCol = new Map();
      for(const inv of invaders){ if(!inv.alive) continue; const col = Math.round((inv.x-180)/64); const prev = byCol.get(col); if(!prev || inv.y>prev.y) byCol.set(col, inv); }
      return Array.from(byCol.values());
    }

    // ===== Main Loop =====
    let last=0;
    function loop(ts){
      const now=ts||0; const dt = Math.min(0.033,(now - last)/1000||0); last=now; 
      // Update game logic only when playing or in transition
      if(state==='playing'||state==='transition') update(dt); 
      draw(); 
      requestAnimationFrame(loop);
    }

    function update(dt){
      player.update(dt);
      
      // Combo timer
      if(comboTimer > 0){
        comboTimer -= dt;
        if(comboTimer <= 0){
          combo = 0;
        }
      }
      
      // Power-up spawning (more frequent for casual play)
      powerUpTimer -= dt;
      if(powerUpTimer <= 0 && Math.random() < 0.6){
        const types = ['rapid', 'multi', 'shield'];
        const type = choice(types);
        powerUps.push(new PowerUp(rand(50, W-50), -30, type));
        powerUpTimer = rand(6, 12); // More frequent spawning
      }
      
      // Update power-ups
      for(const p of powerUps) p.update(dt);

      // Boss update
      if(boss){
        boss.update(dt);
        if(!boss.alive && state === 'playing'){
          beep('sawtooth',600,.12,.03);
          // Stop UFO tremolo when level cleared
          if(ufo) ufo.stopTremolo();
          nextLevel();
          return;
        }
      } else {
        // Invader marching
        const alive = invaders.filter(i=>i.alive);
        if(alive.length===0 && state === 'playing'){ 
          beep('sawtooth',600,.12,.03);
          // Stop UFO tremolo when level cleared
          if(ufo) ufo.stopTremolo();
          nextLevel(); 
          return; 
        }
      }

      if(!boss){
        // bounds of alive invaders
        const alive = invaders.filter(i=>i.alive);
        let minX=Infinity, maxX=-Infinity, maxY=-Infinity;
        for(const i of alive){ if(i.x<minX) minX=i.x; if(i.x>maxX) maxX=i.x; if(i.y>maxY) maxY=i.y; }
        const edgeLeft = (minX-30) <= 10;
        const edgeRight = (maxX+30) >= (W-10);
        if((edgeLeft && invDir<0) || (edgeRight && invDir>0)){ invDir*=-1; for(const i of alive){ i.y += invStepDown; } invSpeed += 6; beep('triangle',220,.05,.008); }
        for(const i of alive){ 
          i.update(dt);
          i.x += invDir * invSpeed * dt * i.speedMultiplier;
          
          // Check invader collision with shields - destroy shield blocks
          for(const sh of shields){
            const invRect = i.rect();
            // Check if invader overlaps shield area
            if(invRect.x < sh.x + sh.cols * sh.cell/2 &&
               invRect.x + invRect.w > sh.x - sh.cols * sh.cell/2 &&
               invRect.y < sh.y + sh.rows * sh.cell/2 &&
               invRect.y + invRect.h > sh.y - sh.rows * sh.cell/2){
              // Clear overlapping shield cells
              for(let r = 0; r < sh.rows; r++){
                for(let c = 0; c < sh.cols; c++){
                  const cellX = sh.x - sh.cols * sh.cell/2 + c * sh.cell;
                  const cellY = sh.y - sh.rows * sh.cell/2 + r * sh.cell;
                  if(cellX < invRect.x + invRect.w &&
                     cellX + sh.cell > invRect.x &&
                     cellY < invRect.y + invRect.h &&
                     cellY + sh.cell > invRect.y){
                    sh.grid[r][c] = 0; // Destroy shield cell
                  }
                }
              }
            }
          }
        }

        // Enemy fire
        fireTimer -= dt;
        if(fireTimer<=0){
          const bottoms = bottomInvadersByColumn();
          if(bottoms.length){ const shooter = choice(bottoms); enemyBullets.push(new Bullet(shooter.x, shooter.y+16, rand(160,220), 'enemy')); beep('sine', 220, .05, .01); }
          fireTimer = clamp(1.1 - level*0.05, 0.3, 1.1);
        }
        
        // Lose when invaders reach player line
        if(maxY >= player.y - 10){ 
          // Final explosion when invaders reach player
          createExplosion(player.x, player.y, '#ff4444', 30);
          floatingTexts.push(new FloatingText('OVERRUN!', W/2, H/2));
          gameOver(); 
        }
      }

      // UFO spawn (not during boss battles)
      if(!boss){
        ufoTimer -= dt; 
        if(ufoTimer<=0 && !ufo){ 
          ufo = new UFO(); 
          // UFO now plays tremolo sound automatically
          ufoTimer = rand(16, 28); 
        }
        if(ufo){ 
          ufo.update(dt); 
          if(!ufo.alive) ufo=null; 
        }
      }

      // Bullets
      for(const b of bullets) b.update(dt);
      for(const b of enemyBullets) b.update(dt);

      // Player bullets vs invaders/UFO/shields
      for(const b of bullets){ if(b.dead) continue; const br=b.rect();
        for(const inv of invaders){ if(!inv.alive) continue; if(overlap(br, inv.rect())){ 
          inv.alive=false; b.dead=true; 
          
          // Combo system
          combo++;
          sessionStats.enemiesDestroyed++;
          comboTimer = 2.5; // 2.5 seconds to maintain combo (more forgiving)
          const comboMultiplier = Math.min(combo, 10);
          const points = inv.value * comboMultiplier;
          score += points;
          updateHUD();
          checkAllAchievements();
          
          // Show combo feedback
          if(combo > 1){
            const comboText = combo >= 10 ? `MAX COMBO x${comboMultiplier}!` : `x${comboMultiplier} COMBO`;
            floatingTexts.push(new FloatingText(comboText, inv.x, inv.y - 20));
            floatingTexts.push(new FloatingText(`+${points}`, inv.x, inv.y));
            const pitch = 300 + combo * 50;
            beep('square', Math.min(pitch, 800), .06, .02);
          } else {
            beep('square', 300, .06, .02);
          }
          
          // Create explosion for invader
          const colors = ['#8aa0ff','#8aa0ff','#66e6ff','#66e6ff','#98ffcc'];
          createExplosion(inv.x, inv.y, colors[inv.row] || '#98ffcc', 15 + combo);
          break; 
        }}
        if(!b.dead){ for(const sh of shields){ if(sh.hit(b.x, b.y)){ b.dead=true; break; } } }
        if(!b.dead && ufo){ if(overlap(br, ufo.rect())){ 
          combo = 0; // UFO resets combo but gives big points
          score+=ufo.points; updateHUD(); 
          floatingTexts.push(new FloatingText(`+${ufo.points}`, ufo.x, ufo.y-10)); 
          ufo.stopTremolo(); // Stop tremolo sound when destroyed
          ufo.alive=false; b.dead=true; 
          
          // Special UFO destruction sound - descending melody
          beep('square', 1200, .08, .04);
          setTimeout(() => beep('square', 900, .08, .04), 80);
          setTimeout(() => beep('square', 600, .08, .04), 160);
          setTimeout(() => beep('sawtooth', 400, .12, .05), 240);
          
          // Create bigger explosion for UFO
          createExplosion(ufo.x, ufo.y, '#ff6d7a', 25);
        }}
        
        // Boss collision
        if(!b.dead && boss){ if(overlap(br, boss.rect())){ 
          boss.hit(); b.dead=true; 
          beep('square', 400, .08, .03);
          createExplosion(b.x, b.y, '#ff4444', 8);
          if(!boss.alive) {
            sessionStats.bossesDefeated++;
            checkAllAchievements();
          }
        }}
      }

      // Enemy bullets vs player/shields
      for(const b of enemyBullets){ if(b.dead) continue; const br=b.rect();
        for(const sh of shields){ if(sh.hit(b.x, b.y)){ b.dead=true; break; } }
        if(b.dead) continue;
        if(overlap(br, player.rect()) && player.invulnerable <= 0){ 
          b.dead=true; lives--; updateHUD(); 
          beep('triangle',120,.12,.02); 
          screenFlash(); 
          
          // Player hit particle explosion
          createExplosion(player.x, player.y, '#ff4444', 20);
          floatingTexts.push(new FloatingText('HIT!', player.x, player.y - 30));
          
          // Set invulnerability period
          player.invulnerable = 1.5;
          
          if(lives<=0) return gameOver(); 
          player.x=W/2; 
          enemyBullets = enemyBullets.filter(bb=>bb.y < player.y-40); 
        }
      }

      // Player vs power-ups
      for(const p of powerUps){
        if(p.dead) continue;
        if(overlap(p.rect(), player.rect())){
          p.dead = true;
          
          sessionStats.powerUpsCollected++;
          
          if(p.type === 'shield'){
            // Repair shields back to original U shape
            for(const sh of shields){
              for(let r = 0; r < sh.rows; r++){
                for(let c = 0; c < sh.cols; c++){
                  let shouldHaveBlock = false;
                  
                  // Recreate U shape logic
                  if(r < 2) {
                    shouldHaveBlock = true;
                  } else if(r < 4) {
                    if(c < 3 || c > 8) shouldHaveBlock = true;
                  } else {
                    if(c < 2 || c > 9) shouldHaveBlock = true;
                  }
                  
                  if(shouldHaveBlock && sh.grid[r][c] === 0) {
                    sh.grid[r][c] = 1; // Restore blocks
                  }
                }
              }
            }
            floatingTexts.push(new FloatingText('SHIELDS REPAIRED!', player.x, player.y - 40));
            // Special power-up sound - ascending notes
            beep('sawtooth', 600, .08, .03);
            setTimeout(() => beep('sawtooth', 800, .08, .03), 80);
            setTimeout(() => beep('sawtooth', 1000, .08, .03), 160);
          } else {
            player.powerUp = p.type;
            player.powerUpTime = 8; // 8 seconds duration
            const text = p.type === 'rapid' ? 'RAPID FIRE!' : 'MULTI-SHOT!';
            floatingTexts.push(new FloatingText(text, player.x, player.y - 40));
            // Power-up acquired sound - ascending notes
            beep('square', 400, .06, .025);
            setTimeout(() => beep('square', 600, .06, .025), 60);
            setTimeout(() => beep('square', 800, .08, .03), 120);
          }
          
          checkAllAchievements();
        }
      }
      
      bullets = bullets.filter(b=>!b.dead);
      enemyBullets = enemyBullets.filter(b=>!b.dead);
      powerUps = powerUps.filter(p=>!p.dead);

      // Floating texts
      for(const ft of floatingTexts) ft.update(dt);
      floatingTexts = floatingTexts.filter(t=>!t.dead);
      
      // Particles
      for(const p of particles) p.update(dt);
      particles = particles.filter(p => p.life > 0);
    }

    // Simple flash on damage
    let flashT=0; function screenFlash(){ flashT=0.18; }

    // Floating text
    class FloatingText{ constructor(text,x,y){ this.text=text; this.x=x; this.y=y; this.t=0; this.dead=false; }
      update(dt){ this.t+=dt; this.y-=30*dt; if(this.t>0.8) this.dead=true; }
      draw(){ ctx.globalAlpha = 1 - this.t/0.8; ctx.fillStyle='#fff2b3'; ctx.font='700 18px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha=1; }
    }
    let floatingTexts=[];

    // Particle system for explosions
    class Particle{
      constructor(x, y, color){
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 280;
        this.vy = (Math.random() - 0.5) * 280;
        this.life = 1;
        this.color = color;
        this.size = Math.random() * 4 + 2;
      }
      update(dt){
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life -= dt * 2;
        if(this.life <= 0) this.life = 0;
      }
      draw(){
        if(this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        const size = this.size * this.life;
        ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
        // Glow effect
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x - size/4, this.y - size/4, size/2, size/2);
        ctx.restore();
      }
    }
    
    let particles = [];
    
    function createExplosion(x, y, color, count = null){
      // Use mobile-optimized particle count if not specified
      if(count === null) count = PARTICLE_COUNT;
      
      // Limit particles on mobile for performance
      if(particles.length > MAX_PARTICLES) particles.splice(0, 50);
      
      for(let i = 0; i < count; i++){
        particles.push(new Particle(x, y, color));
      }
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      drawStars();
      for(const sh of shields) sh.draw();
      for(const p of powerUps) p.draw();
      if(player) player.draw();
      for(const i of invaders) i.draw();
      for(const b of bullets) b.draw();
      for(const b of enemyBullets) b.draw();
      if(ufo) ufo.draw();
      if(boss) boss.draw();
      for(const p of particles) p.draw();
      for(const ft of floatingTexts) ft.draw();
      
      // Wave transition effect
      if(waveTransition){
        const progress = 1 - (waveTransitionTimer / 2.5);
        ctx.save();
        ctx.fillStyle = `rgba(11,15,26,${0.8 * Math.sin(progress * Math.PI)})`;
        ctx.fillRect(0, 0, W, H);
        
        // Wave text
        ctx.fillStyle = '#42ff88';
        ctx.font = 'bold 48px ui-sans-serif, system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if(isBossLevel){
          ctx.fillStyle = '#ff4444';
          ctx.fillText(`LEVEL ${level}`, W/2, H/2 - 40);
          ctx.fillText('BOSS BATTLE!', W/2, H/2 + 20);
        } else {
          ctx.fillText(`WAVE ${level}`, W/2, H/2);
        }
        
        ctx.restore();
        waveTransitionTimer -= 0.016;
      }
      
      if(flashT>0){ ctx.fillStyle='rgba(255,255,255,'+flashT.toFixed(2)+')'; ctx.fillRect(0,0,W,H); flashT-=0.016; }
    }

    // Starfield backdrop
    const stars = Array.from({length:130},()=>({x:Math.random()*W, y:Math.random()*H, s: Math.random()*1.5+0.5}));
    function drawStars(){
      ctx.save();
      for(const st of stars){ st.y+= st.s*0.4; if(st.y>H) st.y=0; ctx.globalAlpha = clamp(0.5 + st.s/2, 0.5, 1); ctx.fillStyle='#bac6ff'; ctx.fillRect(st.x, st.y, 2, 2); }
      ctx.globalAlpha=1; ctx.restore();
    }

    // --- Self-tests (run once on load; see console) ---
    function runSelfTests(){
      const results=[]; let passed=0; const assert=(name, cond)=>{ console.assert(cond, 'FAIL:', name); if(cond){passed++; results.push('✔ '+name);} else { results.push('✖ '+name);} };
      try{
        // Test 1: Shield.draw doesn't throw (typo regression)
        const sh = new Shield(100,100);
        try{ sh.draw(); assert('Shield.draw executes without ReferenceError', true); }catch(e){ assert('Shield.draw executes without ReferenceError', false); console.error(e); }

        // Test 2: Shield.hit depletes correctly (2 → 1 → 0)
        const px=sh.x, py=sh.y;
        const hit1=sh.hit(px,py); const hit2=sh.hit(px,py); const hit3=sh.hit(px,py);
        assert('Shield.hit returns true, true, then false', hit1 && hit2 && !hit3);

        // Test 3: Special attack adds 7 wide bullets and locks
        const savedState=state, savedBulletsLen=bullets.length, savedPlayer=player, savedSpecial=specialAvailable;
        state='playing'; player=new Player(); player.x=W/2; specialAvailable=true;
        const before=bullets.length; useSpecial(); const after=bullets.length; const added=after-before;
        const widthsOK = bullets.slice(-added).every(b=>b.w>=6);
        assert('useSpecial adds exactly 7 wide bullets once', added===7 && widthsOK && specialAvailable===false);
        // cleanup
        bullets.length=savedBulletsLen; player=savedPlayer; specialAvailable=savedSpecial; state=savedState;

        // Test 4: Game over when invader reaches player line
        state='playing'; player=new Player(); invaders=[new Invader(200, player.y-20, 0)]; shields=[]; bullets=[]; enemyBullets=[];
        update(0); assert('Invaders above player line do NOT end game', state==='playing');
        invaders[0].y = player.y - 5; update(0); assert('Invaders reaching player line DO end game', state==='gameover');
        state='title';
      }catch(e){ console.error('Self-tests crashed', e); }
      console.groupCollapsed('Invaders self-tests'); results.forEach(r=>console.log(r)); console.log(`${passed}/${results.length} tests passed`); console.groupEnd();
    }

    // Buttons
    document.getElementById('btn-start').addEventListener('click', startGame);
    document.getElementById('btn-restart').addEventListener('click', ()=>{ restart(); startGame(); });
    
    // Tutorial button
    document.getElementById('btn-tutorial').addEventListener('click', () => {
      document.getElementById('screen-title').classList.add('hidden');
      document.getElementById('screen-tutorial').classList.remove('hidden');
    });
    
    document.getElementById('btn-tutorial-close').addEventListener('click', () => {
      document.getElementById('screen-tutorial').classList.add('hidden');
      document.getElementById('screen-title').classList.remove('hidden');
    });

    // Prevent page scroll on space/arrow
    window.addEventListener('keydown', e=>{ if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); }, {passive:false});

    // Debug helpers
    window.__invaders__ = { mute(v){ muted=!!v; }, resetHi(){ localStorage.removeItem('inv_hi'); hiscore=0; updateHUD(); }, giveSpecial(){ specialAvailable=true; } };

    updateHUD();

    // Run tests, then start loop
    runSelfTests();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
