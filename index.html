<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>インベーダー（Canvas）</title>
  <style>
    :root { --bg:#0b0f1a; --fg:#f2f5ff; --accent:#42ff88; --muted:#8aa0ff; }
    html,body{height:100%;}
    body{margin:0; background:radial-gradient(1200px 600px at 50% -200px,#101426 0%, #0b0f1a 60%, #070a12 100%); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "メイリオ", Meiryo, "Apple Color Emoji", "Segoe UI Emoji";}
    #wrap{position:relative; width:min(100vw, 960px); margin:0 auto;}
    canvas{width:100%; height:auto; display:block; background:transparent;}
    .hud{position:absolute; inset:0; pointer-events:none;}
    .row{display:flex; justify-content:space-between; align-items:center; gap:8px; padding:10px 12px; font-weight:700; letter-spacing:.02em; text-shadow:0 2px 12px rgba(0,0,0,.45)}
    .score, .lives, .level{font-variant-numeric:tabular-nums;}
    .pill{display:inline-block; padding:.25rem .5rem; border-radius:9999px; background:rgba(255,255,255,.06); box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);}
    .center{position:absolute; inset:0; display:grid; place-items:center;}
    .panel{pointer-events:auto; text-align:center; background:rgba(6,10,18,.74); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:22px 24px; backdrop-filter: blur(8px); box-shadow:0 10px 40px rgba(0,0,0,.35);}
    .panel h1{margin:.1rem 0 0.35rem; font-size:clamp(24px, 5vw, 40px); letter-spacing:.04em;}
    .panel p{margin:.4rem 0; color:#c8d0ff; font-size:clamp(12px, 2.8vw, 16px)}
    .kbd{display:inline-block; min-width:1.6em; text-align:center; padding:.18rem .45rem; border-radius:8px; background:#0d1322; border:1px solid rgba(255,255,255,.14); box-shadow: inset 0 -2px 0 rgba(255,255,255,.06), 0 4px 16px rgba(0,0,0,.35);}
    .btn{pointer-events:auto; cursor:pointer; margin-top:.6rem; display:inline-block; background:linear-gradient(180deg,#2ef29f,#19ce85); color:#02120a; font-weight:800; border:none; padding:.6rem 1rem; border-radius:12px; box-shadow:0 10px 30px rgba(23, 232, 142, .45);}
    .tiny{font-size:12px; opacity:.85}
    .hidden{display:none}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="600" aria-label="インベーダーゲーム"></canvas>
    <div class="hud" aria-hidden="true">
      <div class="row">
        <div class="score">SCORE: <span id="score">0000</span></div>
        <div class="pill">HIGH: <span id="hiscore">0000</span></div>
        <div class="level">LEVEL: <span id="level">1</span></div>
        <div class="lives">LIVES: <span id="lives">3</span></div>
      </div>
      <div class="center">
        <div id="screen-title" class="panel">
          <h1>SPACE INVADERS</h1>
          <p><span class="kbd">←</span> / <span class="kbd">→</span> または <span class="kbd">A</span> / <span class="kbd">D</span>：移動　　<span class="kbd">SPACE</span>：ショット</p>
          <p><span class="kbd">SHIFT</span>：必殺技（1回だけ）</p>
          <p><span class="kbd">P</span>：一時停止　　<span class="kbd">R</span>：やり直し</p>
          <p class="tiny">時々、上空に<span style="color:var(--accent); font-weight:800;">UFO</span>が出現！ 撃墜で高得点（50 / 100 / 150 / 300）。</p>
          <button id="btn-start" class="btn">ゲーム開始（Enter）</button>
        </div>
        <div id="screen-gameover" class="panel hidden">
          <h1>GAME OVER</h1>
          <p>スコア：<span id="final-score">0</span>　ハイスコア：<span id="final-hiscore">0</span></p>
          <button id="btn-restart" class="btn">もう一度（R）</button>
        </div>
        <div id="screen-paused" class="panel hidden">
          <h1>PAUSED</h1>
          <p>再開は <span class="kbd">P</span></p>
        </div>
      </div>
    </div>
  </div>

  <script>
  (()=>{
    // ===== Utility =====
    const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
    const rand=(a,b)=>Math.random()*(b-a)+a;
    const choice=arr=>arr[(Math.random()*arr.length)|0];

    // High DPI scaling
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // scale drawing to CSS pixels
    }
    new ResizeObserver(resizeCanvas).observe(canvas);
    resizeCanvas();

    // ===== Game State =====
    const W=960, H=600;
    canvas.style.aspectRatio = `${W}/${H}`;

    let state='title';
    let score=0, hiscore= Number(localStorage.getItem('inv_hi')||0), level=1, lives=3;
    let specialAvailable = true; // 1ゲームに1回

    // HUD hooks
    const $ = sel => document.querySelector(sel);
    const scrEl = $('#score');
    const hiEl  = $('#hiscore');
    const lvEl  = $('#level');
    const livesEl = $('#lives');
    const titleScreen = $('#screen-title');
    const overScreen = $('#screen-gameover');
    const pausedScreen = $('#screen-paused');

    function updateHUD(){
      scrEl.textContent = score.toString().padStart(4,'0');
      hiEl.textContent  = hiscore.toString().padStart(4,'0');
      lvEl.textContent  = level;
      livesEl.textContent = lives;
    }

    // ===== Input =====
    const keys = new Set();
    const down = e=>{
      keys.add(e.code);
      if(state==='title' && (e.code==='Enter' || e.code==='Space')) startGame();
      if(e.code==='KeyP') togglePause();
      if(e.code==='KeyR') restart();
      if(e.code==='ShiftLeft' || e.code==='ShiftRight'){ useSpecial(); }
    };
    const up = e=>{ keys.delete(e.code); };
    window.addEventListener('keydown', down);
    window.addEventListener('keyup', up);

    // ===== Audio =====
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audio = new AudioCtx();
    let muted = false;
    function beep(type='square', freq=440, dur=0.06, gain=0.015){
      if(muted || audio.state!=='running') return;
      const t0 = audio.currentTime;
      const o = audio.createOscillator();
      const g = audio.createGain();
      o.type = type; o.frequency.value=freq;
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g).connect(audio.destination);
      o.start(t0); o.stop(t0+dur);
    }
    window.addEventListener('pointerdown', ()=>{ if(audio.state!=='running') audio.resume(); }, {once:true});

    // ===== Entities =====
    class Bullet{
      constructor(x,y,vy,from,w=3,h=10){this.x=x; this.y=y; this.vy=vy; this.w=w; this.h=h; this.from=from; this.dead=false;}
      update(dt){ this.y += this.vy*dt; if(this.y<-40||this.y>H+40) this.dead=true; }
      draw(){ ctx.fillStyle = this.from==='player'? '#42ff88' : '#ff8a8a'; ctx.fillRect(this.x-this.w/2, this.y-this.h/2, this.w, this.h); }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    class Player{
      constructor(){ this.x=W/2; this.y=H-60; this.w=40; this.h=22; this.speed=320; this.cool=0; }
      update(dt){
        const left = keys.has('ArrowLeft')||keys.has('KeyA');
        const right = keys.has('ArrowRight')||keys.has('KeyD');
        let ax = (right?1:0) - (left?1:0);
        this.x += ax * this.speed * dt;
        this.x = clamp(this.x, 24, W-24);
        this.cool -= dt;
        if(keys.has('Space') && this.cool<=0 && bullets.filter(b=>b.from==='player').length<2){
          bullets.push(new Bullet(this.x, this.y-18, -480, 'player'));
          this.cool = 0.12;
          beep('square', 880, .06, .02);
        }
      }
      draw(){
        ctx.save(); ctx.translate(this.x, this.y);
        ctx.fillStyle = '#c7f7ff';
        ctx.fillRect(-20, 6, 40, 6);
        ctx.fillRect(-12, 0, 24, 8);
        ctx.fillRect(-4, -8, 8, 16);
        ctx.restore();
      }
      rect(){ return {x:this.x-20, y:this.y-8, w:40, h:22}; }
    }

    // Special attack (1回/ゲーム)
    function useSpecial(){
      if(!specialAvailable || state!=='playing') return;
      specialAvailable = false;
      // ワイドミサイル: 左右に広がる7連射（太弾）
      for(let i=-3;i<=3;i++){
        const dx = i*12;
        bullets.push(new Bullet(player.x + dx, player.y-18, -520, 'player', 6, 18));
      }
      beep('sawtooth', 500, .2, .05);
      floatingTexts.push(new FloatingText('必殺技!', player.x, player.y-30));
    }

    class Invader{ constructor(x,y,row){ this.x=x; this.y=y; this.w=30; this.h=22; this.row=row; this.alive=true; this.anim=0; this.value= [30,30,20,20,10][row] || 10; }
      draw(){ if(!this.alive) return; ctx.save(); ctx.translate(this.x, this.y); this.anim+=0.08; const t=this.anim; ctx.fillStyle = ['#8aa0ff','#8aa0ff','#66e6ff','#66e6ff','#98ffcc'][this.row]||'#98ffcc';
        const up = Math.sin(t)>0;
        const w=this.w, h=this.h;
        ctx.fillRect(-w/2, -h/2, w, 6);
        ctx.fillRect(-w/2+ (up?4:2), -h/2+6, w-(up?8:4), 6);
        ctx.fillRect(-w/2+ (up?10:8), -h/2+12, w-(up?20:16), 6);
        ctx.restore(); }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    class Shield{ constructor(x,y){ this.x=x; this.y=y; this.cell=8; this.cols=12; this.rows=6; this.grid=Array.from({length:this.rows},()=>Array(this.cols).fill(2)); }
      hit(px,py){ const lx = Math.floor((px - (this.x - this.cols*this.cell/2))/this.cell); const ly = Math.floor((py - (this.y - this.rows*this.cell/2))/this.cell); if(lx<0||ly<0||lx>=this.cols||ly>=this.rows) return false; if(this.grid[ly][lx]>0){ this.grid[ly][lx]--; return true; } return false; }
      draw(){ ctx.save(); ctx.translate(this.x - this.cols*this.cell/2, this.y - this.rows*this.cell/2); for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){ const hp=this.grid[r][c]; if(hp<=0) continue; ctx.globalAlpha=hp===2?1:0.55; ctx.fillStyle='#7bffb9'; ctx.fillRect(c*this.cell, r*this.cell, this.cell-1, this.cell-1);} ctx.globalAlpha=1; ctx.restore(); }
    }

    class UFO{ constructor(){ this.w=50; this.h=22; this.y=72; this.x = Math.random()<0.5? -60 : W+60; this.vx = this.x<0? rand(110,160) : -rand(110,160); this.alive=true; this.points= choice([50,100,150,300]); }
      update(dt){ this.x += this.vx*dt; if(this.x<-100||this.x>W+100) this.alive=false; }
      draw(){ if(!this.alive) return; ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle='#ff6d7a'; ctx.fillRect(-24,-6,48,12); ctx.fillRect(-16,-10,32,8); ctx.fillStyle='#ffd1d6'; ctx.fillRect(-6,-14,12,6); ctx.restore(); }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    // ===== World containers =====
    let player; let invaders=[]; let bullets=[]; let enemyBullets=[]; let shields=[]; let ufo=null; let invDir=1; let invSpeed=32; let invStepDown=18; let fireTimer=0; let ufoTimer=rand(12,24);

    function setupLevel(){
      invaders.length=0; bullets.length=0; enemyBullets.length=0; ufo=null;
      const cols=11, rows=5; const startX=120, gapX=64, startY=120, gapY=40;
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        invaders.push(new Invader(startX + c*gapX, startY + r*gapY, r));
      }
      invDir=1; invSpeed= 28 + (level-1)*4; // レベルで少し速く
      const y=H-140; shields=[ new Shield(W*0.2,y), new Shield(W*0.5,y), new Shield(W*0.8,y) ];
    }

    function startGame(){
      state='playing'; score=0; level=1; lives=3; specialAvailable=true;
      player = new Player(); setupLevel(); updateHUD(); hideAllPanels();
      if(audio.state!=='running') audio.resume();
    }

    function nextLevel(){ level++; invSpeed += 6; setupLevel(); updateHUD(); }

    function restart(){ state='title'; hideAllPanels(); titleScreen.classList.remove('hidden'); }

    function gameOver(){
      state='gameover'; hiscore = Math.max(hiscore, score); localStorage.setItem('inv_hi', String(hiscore)); updateHUD();
      document.getElementById('final-score').textContent = String(score);
      document.getElementById('final-hiscore').textContent = String(hiscore);
      hideAllPanels(); overScreen.classList.remove('hidden');
    }

    function togglePause(){ if(state==='playing'){ state='paused'; pausedScreen.classList.remove('hidden'); } else if(state==='paused'){ state='playing'; pausedScreen.classList.add('hidden'); } }

    function hideAllPanels(){ titleScreen.classList.add('hidden'); overScreen.classList.add('hidden'); pausedScreen.classList.add('hidden'); }

    // ===== Collision & helpers =====
    function overlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    function bottomInvadersByColumn(){
      const byCol = new Map();
      for(const inv of invaders){ if(!inv.alive) continue; const col = Math.round((inv.x-120)/64); const prev = byCol.get(col); if(!prev || inv.y>prev.y) byCol.set(col, inv); }
      return Array.from(byCol.values());
    }

    // ===== Main Loop =====
    let last=0;
    function loop(ts){
      const now=ts||0; const dt = Math.min(0.033,(now - last)/1000||0); last=now; if(state==='playing') update(dt); draw(); requestAnimationFrame(loop);
    }

    function update(dt){
      player.update(dt);

      // Invader marching
      const alive = invaders.filter(i=>i.alive);
      if(alive.length===0){ beep('sawtooth',600,.12,.03); nextLevel(); return; }

      // bounds of alive invaders
      let minX=Infinity, maxX=-Infinity, maxY=-Infinity;
      for(const i of alive){ if(i.x<minX) minX=i.x; if(i.x>maxX) maxX=i.x; if(i.y>maxY) maxY=i.y; }
      const edgeLeft = (minX-30) <= 10;
      const edgeRight = (maxX+30) >= (W-10);
      if((edgeLeft && invDir<0) || (edgeRight && invDir>0)){ invDir*=-1; for(const i of alive){ i.y += invStepDown; } invSpeed += 6; beep('triangle',220,.05,.008); }
      for(const i of alive){ i.x += invDir * invSpeed * dt; }

      // Enemy fire
      fireTimer -= dt;
      if(fireTimer<=0){
        const bottoms = bottomInvadersByColumn();
        if(bottoms.length){ const shooter = choice(bottoms); enemyBullets.push(new Bullet(shooter.x, shooter.y+16, rand(160,220), 'enemy')); beep('sine', 220, .05, .01); }
        fireTimer = clamp(1.1 - level*0.05, 0.3, 1.1);
      }

      // UFO spawn
      ufoTimer -= dt; if(ufoTimer<=0 && !ufo){ ufo = new UFO(); beep('sawtooth', 520, .08, .018); ufoTimer = rand(16, 28); }
      if(ufo){ ufo.update(dt); if(!ufo.alive) ufo=null; }

      // Bullets
      for(const b of bullets) b.update(dt);
      for(const b of enemyBullets) b.update(dt);

      // Player bullets vs invaders/UFO/shields
      for(const b of bullets){ if(b.dead) continue; const br=b.rect();
        for(const inv of invaders){ if(!inv.alive) continue; if(overlap(br, inv.rect())){ inv.alive=false; b.dead=true; score+=inv.value; updateHUD(); beep('square', 300, .06, .02); break; } }
        if(!b.dead){ for(const sh of shields){ if(sh.hit(b.x, b.y)){ b.dead=true; break; } } }
        if(!b.dead && ufo){ if(overlap(br, ufo.rect())){ score+=ufo.points; updateHUD(); floatingTexts.push(new FloatingText(`+${ufo.points}`, ufo.x, ufo.y-10)); ufo.alive=false; b.dead=true; beep('square', 900, .09, .03); }
        }
      }

      // Enemy bullets vs player/shields
      for(const b of enemyBullets){ if(b.dead) continue; const br=b.rect();
        for(const sh of shields){ if(sh.hit(b.x, b.y)){ b.dead=true; break; } }
        if(b.dead) continue;
        if(overlap(br, player.rect())){ b.dead=true; lives--; updateHUD(); beep('triangle',120,.12,.02); screenFlash(); if(lives<=0) return gameOver(); player.x=W/2; enemyBullets = enemyBullets.filter(bb=>bb.y < player.y-40); }
      }

      bullets = bullets.filter(b=>!b.dead);
      enemyBullets = enemyBullets.filter(b=>!b.dead);

      // Lose when invaders reach player line（プレーヤー位置付近）
      if(maxY >= player.y - 10){ gameOver(); }

      // Floating texts
      for(const ft of floatingTexts) ft.update(dt);
      floatingTexts = floatingTexts.filter(t=>!t.dead);
    }

    // Simple flash on damage
    let flashT=0; function screenFlash(){ flashT=0.18; }

    // Floating text
    class FloatingText{ constructor(text,x,y){ this.text=text; this.x=x; this.y=y; this.t=0; this.dead=false; }
      update(dt){ this.t+=dt; this.y-=30*dt; if(this.t>0.8) this.dead=true; }
      draw(){ ctx.globalAlpha = 1 - this.t/0.8; ctx.fillStyle='#fff2b3'; ctx.font='700 18px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha=1; }
    }
    let floatingTexts=[];

    function draw(){
      ctx.clearRect(0,0,W,H);
      drawStars();
      for(const sh of shields) sh.draw();
      if(player) player.draw();
      for(const i of invaders) i.draw();
      for(const b of bullets) b.draw();
      for(const b of enemyBullets) b.draw();
      if(ufo) ufo.draw();
      for(const ft of floatingTexts) ft.draw();
      if(flashT>0){ ctx.fillStyle='rgba(255,255,255,'+flashT.toFixed(2)+')'; ctx.fillRect(0,0,W,H); flashT-=0.016; }
    }

    // Starfield backdrop
    const stars = Array.from({length:130},()=>({x:Math.random()*W, y:Math.random()*H, s: Math.random()*1.5+0.5}));
    function drawStars(){
      ctx.save();
      for(const st of stars){ st.y+= st.s*0.4; if(st.y>H) st.y=0; ctx.globalAlpha = clamp(0.5 + st.s/2, 0.5, 1); ctx.fillStyle='#bac6ff'; ctx.fillRect(st.x, st.y, 2, 2); }
      ctx.globalAlpha=1; ctx.restore();
    }

    // --- Self-tests (run once on load; see console) ---
    function runSelfTests(){
      const results=[]; let passed=0; const assert=(name, cond)=>{ console.assert(cond, 'FAIL:', name); if(cond){passed++; results.push('✔ '+name);} else { results.push('✖ '+name);} };
      try{
        // Test 1: Shield.draw doesn't throw (typo regression)
        const sh = new Shield(100,100);
        try{ sh.draw(); assert('Shield.draw executes without ReferenceError', true); }catch(e){ assert('Shield.draw executes without ReferenceError', false); console.error(e); }

        // Test 2: Shield.hit depletes correctly (2 → 1 → 0)
        const px=sh.x, py=sh.y;
        const hit1=sh.hit(px,py); const hit2=sh.hit(px,py); const hit3=sh.hit(px,py);
        assert('Shield.hit returns true, true, then false', hit1 && hit2 && !hit3);

        // Test 3: Special attack adds 7 wide bullets and locks
        const savedState=state, savedBulletsLen=bullets.length, savedPlayer=player, savedSpecial=specialAvailable;
        state='playing'; player=new Player(); player.x=W/2; specialAvailable=true;
        const before=bullets.length; useSpecial(); const after=bullets.length; const added=after-before;
        const widthsOK = bullets.slice(-added).every(b=>b.w>=6);
        assert('useSpecial adds exactly 7 wide bullets once', added===7 && widthsOK && specialAvailable===false);
        // cleanup
        bullets.length=savedBulletsLen; player=savedPlayer; specialAvailable=savedSpecial; state=savedState;

        // Test 4: Game over when invader reaches player line
        state='playing'; player=new Player(); invaders=[new Invader(200, player.y-20, 0)]; shields=[]; bullets=[]; enemyBullets=[];
        update(0); assert('Invaders above player line do NOT end game', state==='playing');
        invaders[0].y = player.y - 5; update(0); assert('Invaders reaching player line DO end game', state==='gameover');
        state='title';
      }catch(e){ console.error('Self-tests crashed', e); }
      console.groupCollapsed('Invaders self-tests'); results.forEach(r=>console.log(r)); console.log(`${passed}/${results.length} tests passed`); console.groupEnd();
    }

    // Buttons
    document.getElementById('btn-start').addEventListener('click', startGame);
    document.getElementById('btn-restart').addEventListener('click', ()=>{ restart(); startGame(); });

    // Prevent page scroll on space/arrow
    window.addEventListener('keydown', e=>{ if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); }, {passive:false});

    // Debug helpers
    window.__invaders__ = { mute(v){ muted=!!v; }, resetHi(){ localStorage.removeItem('inv_hi'); hiscore=0; updateHUD(); }, giveSpecial(){ specialAvailable=true; } };

    updateHUD();

    // Run tests, then start loop
    runSelfTests();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
