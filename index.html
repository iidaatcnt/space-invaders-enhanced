<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>„Ç§„É≥„Éô„Éº„ÉÄ„ÉºÔºàCanvasÔºâ</title>
  <style>
    :root { --bg:#0b0f1a; --fg:#f2f5ff; --accent:#42ff88; --muted:#8aa0ff; }
    html,body{height:100%;}
    body{margin:0; background:radial-gradient(1200px 600px at 50% -200px,#101426 0%, #0b0f1a 60%, #070a12 100%); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "„É°„Ç§„É™„Ç™", Meiryo, "Apple Color Emoji", "Segoe UI Emoji";}
    #wrap{position:relative; width:min(100vw, 960px); margin:0 auto;}
    canvas{width:100%; height:auto; display:block; background:transparent; touch-action:none;}
    .hud{position:absolute; inset:0; pointer-events:none;}
    .row{display:flex; justify-content:space-between; align-items:center; gap:8px; padding:10px 12px; font-weight:700; letter-spacing:.02em; text-shadow:0 2px 12px rgba(0,0,0,.45)}
    .score, .lives, .level{font-variant-numeric:tabular-nums;}
    .pill{display:inline-block; padding:.25rem .5rem; border-radius:9999px; background:rgba(255,255,255,.06); box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);}
    .center{position:absolute; inset:0; display:grid; place-items:center;}
    .panel{pointer-events:auto; text-align:center; background:rgba(6,10,18,.74); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:22px 24px; backdrop-filter: blur(8px); box-shadow:0 10px 40px rgba(0,0,0,.35);}
    .panel h1{margin:.1rem 0 0.35rem; font-size:clamp(24px, 5vw, 40px); letter-spacing:.04em;}
    .panel p{margin:.4rem 0; color:#c8d0ff; font-size:clamp(12px, 2.8vw, 16px)}
    .kbd{display:inline-block; min-width:1.6em; text-align:center; padding:.18rem .45rem; border-radius:8px; background:#0d1322; border:1px solid rgba(255,255,255,.14); box-shadow: inset 0 -2px 0 rgba(255,255,255,.06), 0 4px 16px rgba(0,0,0,.35);}
    .btn{pointer-events:auto; cursor:pointer; margin-top:.6rem; display:inline-block; background:linear-gradient(180deg,#2ef29f,#19ce85); color:#02120a; font-weight:800; border:none; padding:.6rem 1rem; border-radius:12px; box-shadow:0 10px 30px rgba(23, 232, 142, .45);}
    .tiny{font-size:12px; opacity:.85}
    .hidden{display:none}
    
    /* Mobile controls */
    .mobile-controls{display:none; position:fixed; bottom:0; left:0; right:0; height:120px; pointer-events:auto; user-select:none; -webkit-user-select:none;}
    @media (max-width:768px), (pointer:coarse){
      .mobile-controls{display:flex; justify-content:space-between; align-items:center; padding:0 20px; background:linear-gradient(to top, rgba(11,15,26,0.9), transparent);}
      .mobile-btn{width:60px; height:60px; border-radius:50%; background:rgba(255,255,255,0.1); border:2px solid rgba(255,255,255,0.2); display:grid; place-items:center; font-size:24px; color:var(--fg); touch-action:none;}
      .mobile-btn:active{background:rgba(255,255,255,0.2); transform:scale(0.95);}
      .mobile-fire{width:80px; height:80px; background:rgba(66,255,136,0.2); border-color:var(--accent);}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="600" aria-label="„Ç§„É≥„Éô„Éº„ÉÄ„Éº„Ç≤„Éº„É†"></canvas>
    <div class="hud" aria-hidden="true">
      <div class="row">
        <div class="score">SCORE: <span id="score">0000</span></div>
        <div class="pill">HIGH: <span id="hiscore">0000</span></div>
        <div class="level">LEVEL: <span id="level">1</span></div>
        <div class="lives">LIVES: <span id="lives">3</span></div>
      </div>
      <div class="center">
        <div id="screen-title" class="panel">
          <h1>SPACE INVADERS</h1>
          <p><span class="kbd">‚Üê</span> / <span class="kbd">‚Üí</span> „Åæ„Åü„ÅØ <span class="kbd">A</span> / <span class="kbd">D</span>ÔºöÁßªÂãï„ÄÄ„ÄÄ<span class="kbd">SPACE</span>Ôºö„Ç∑„Éß„ÉÉ„Éà</p>
          <p><span class="kbd">SHIFT</span>ÔºöÂøÖÊÆ∫ÊäÄÔºà1Âõû„Å†„ÅëÔºâ</p>
          <p><span class="kbd">P</span>Ôºö‰∏ÄÊôÇÂÅúÊ≠¢„ÄÄ„ÄÄ<span class="kbd">R</span>Ôºö„ÇÑ„ÇäÁõ¥„Åó</p>
          <p class="tiny">ÊôÇ„ÄÖ„ÄÅ‰∏äÁ©∫„Å´<span style="color:var(--accent); font-weight:800;">UFO</span>„ÅåÂá∫ÁèæÔºÅ ÊíÉÂ¢ú„ÅßÈ´òÂæóÁÇπÔºà50 / 100 / 150 / 300Ôºâ„ÄÇ</p>
          <button id="btn-start" class="btn">„Ç≤„Éº„É†ÈñãÂßãÔºàEnterÔºâ</button>
        </div>
        <div id="screen-gameover" class="panel hidden">
          <h1>GAME OVER</h1>
          <p>„Çπ„Ç≥„Ç¢Ôºö<span id="final-score">0</span>„ÄÄ„Éè„Ç§„Çπ„Ç≥„Ç¢Ôºö<span id="final-hiscore">0</span></p>
          <button id="btn-restart" class="btn">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÔºàRÔºâ</button>
        </div>
        <div id="screen-paused" class="panel hidden">
          <h1>PAUSED</h1>
          <p>ÂÜçÈñã„ÅØ <span class="kbd">P</span></p>
        </div>
      </div>
    </div>
    <!-- Mobile controls -->
    <div class="mobile-controls">
      <button class="mobile-btn" id="mobile-left">‚óÄ</button>
      <button class="mobile-btn mobile-fire" id="mobile-fire">üî•</button>
      <button class="mobile-btn" id="mobile-right">‚ñ∂</button>
    </div>
  </div>

  <script>
  (()=>{
    // ===== Utility =====
    const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
    const rand=(a,b)=>Math.random()*(b-a)+a;
    const choice=arr=>arr[(Math.random()*arr.length)|0];

    // High DPI scaling
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // scale drawing to CSS pixels
    }
    new ResizeObserver(resizeCanvas).observe(canvas);
    resizeCanvas();

    // ===== Game State =====
    const W=960, H=600;
    canvas.style.aspectRatio = `${W}/${H}`;

    let state='title';
    let score=0, hiscore= Number(localStorage.getItem('inv_hi')||0), level=1, lives=3;
    let specialAvailable = true; // 1„Ç≤„Éº„É†„Å´1Âõû
    let combo = 0;
    let comboTimer = 0;

    // HUD hooks
    const $ = sel => document.querySelector(sel);
    const scrEl = $('#score');
    const hiEl  = $('#hiscore');
    const lvEl  = $('#level');
    const livesEl = $('#lives');
    const titleScreen = $('#screen-title');
    const overScreen = $('#screen-gameover');
    const pausedScreen = $('#screen-paused');

    function updateHUD(){
      scrEl.textContent = score.toString().padStart(4,'0');
      hiEl.textContent  = hiscore.toString().padStart(4,'0');
      lvEl.textContent  = level;
      livesEl.textContent = lives;
    }

    // ===== Input =====
    const keys = new Set();
    const down = e=>{
      keys.add(e.code);
      if(state==='title' && (e.code==='Enter' || e.code==='Space')) startGame();
      if(e.code==='KeyP') togglePause();
      if(e.code==='KeyR') restart();
      if(e.code==='ShiftLeft' || e.code==='ShiftRight'){ useSpecial(); }
    };
    const up = e=>{ keys.delete(e.code); };
    window.addEventListener('keydown', down);
    window.addEventListener('keyup', up);
    
    // Mobile controls
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                     ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    
    if(isMobile || window.innerWidth <= 768){
      const mobileLeft = document.getElementById('mobile-left');
      const mobileRight = document.getElementById('mobile-right');
      const mobileFire = document.getElementById('mobile-fire');
      
      // Touch controls
      const handleTouch = (el, code) => {
        el.addEventListener('touchstart', (e) => {
          e.preventDefault();
          keys.add(code);
        });
        el.addEventListener('touchend', (e) => {
          e.preventDefault();
          keys.delete(code);
        });
      };
      
      handleTouch(mobileLeft, 'ArrowLeft');
      handleTouch(mobileRight, 'ArrowRight');
      handleTouch(mobileFire, 'Space');
      
      // Double tap for special attack
      let lastTap = 0;
      mobileFire.addEventListener('touchstart', (e) => {
        const now = Date.now();
        if(now - lastTap < 300){
          useSpecial();
        }
        lastTap = now;
      });
    }

    // ===== Audio =====
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audio = new AudioCtx();
    let muted = false;
    function beep(type='square', freq=440, dur=0.06, gain=0.015){
      if(muted || audio.state!=='running') return;
      const t0 = audio.currentTime;
      const o = audio.createOscillator();
      const g = audio.createGain();
      o.type = type; o.frequency.value=freq;
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g).connect(audio.destination);
      o.start(t0); o.stop(t0+dur);
    }
    window.addEventListener('pointerdown', ()=>{ if(audio.state!=='running') audio.resume(); }, {once:true});

    // ===== Entities =====
    class Bullet{
      constructor(x,y,vy,from,w=3,h=10){this.x=x; this.y=y; this.vy=vy; this.w=w; this.h=h; this.from=from; this.dead=false;}
      update(dt){ this.y += this.vy*dt; if(this.y<-40||this.y>H+40) this.dead=true; }
      draw(){ ctx.fillStyle = this.from==='player'? '#42ff88' : '#ff8a8a'; ctx.fillRect(this.x-this.w/2, this.y-this.h/2, this.w, this.h); }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    class Player{
      constructor(){ 
        this.x=W/2; this.y=H-60; this.w=40; this.h=22; this.speed=320; this.cool=0; 
        this.powerUp = null;
        this.powerUpTime = 0;
      }
      update(dt){
        const left = keys.has('ArrowLeft')||keys.has('KeyA');
        const right = keys.has('ArrowRight')||keys.has('KeyD');
        let ax = (right?1:0) - (left?1:0);
        this.x += ax * this.speed * dt;
        this.x = clamp(this.x, 24, W-24);
        this.cool -= dt;
        
        // Power-up timer
        if(this.powerUp && this.powerUpTime > 0){
          this.powerUpTime -= dt;
          if(this.powerUpTime <= 0){
            this.powerUp = null;
            floatingTexts.push(new FloatingText('Power-up expired', this.x, this.y - 40));
          }
        }
        
        // Shooting with power-ups
        const maxBullets = this.powerUp === 'rapid' ? 5 : 2;
        const cooldown = this.powerUp === 'rapid' ? 0.06 : 0.12;
        
        if(keys.has('Space') && this.cool<=0 && bullets.filter(b=>b.from==='player').length<maxBullets){
          if(this.powerUp === 'multi'){
            // Triple shot
            bullets.push(new Bullet(this.x, this.y-18, -480, 'player'));
            bullets.push(new Bullet(this.x-12, this.y-18, -480, 'player'));
            bullets.push(new Bullet(this.x+12, this.y-18, -480, 'player'));
          } else {
            bullets.push(new Bullet(this.x, this.y-18, -480, 'player'));
          }
          this.cool = cooldown;
          beep('square', 880, .06, .02);
        }
      }
      draw(){
        ctx.save(); ctx.translate(this.x, this.y);
        
        // Power-up aura
        if(this.powerUp){
          ctx.save();
          const auraColor = this.powerUp === 'rapid' ? '#ff9d42' : 
                           this.powerUp === 'multi' ? '#42c3ff' : '#42ff88';
          ctx.strokeStyle = auraColor;
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
          ctx.strokeRect(-24, -12, 48, 26);
          ctx.restore();
        }
        
        ctx.fillStyle = '#c7f7ff';
        ctx.fillRect(-20, 6, 40, 6);
        ctx.fillRect(-12, 0, 24, 8);
        ctx.fillRect(-4, -8, 8, 16);
        ctx.restore();
      }
      rect(){ return {x:this.x-20, y:this.y-8, w:40, h:22}; }
    }

    // Special attack (1Âõû/„Ç≤„Éº„É†)
    function useSpecial(){
      if(!specialAvailable || state!=='playing') return;
      specialAvailable = false;
      // „ÉØ„Ç§„Éâ„Éü„Çµ„Ç§„É´: Â∑¶Âè≥„Å´Â∫É„Åå„Çã7ÈÄ£Â∞ÑÔºàÂ§™ÂºæÔºâ
      for(let i=-3;i<=3;i++){
        const dx = i*12;
        bullets.push(new Bullet(player.x + dx, player.y-18, -520, 'player', 6, 18));
      }
      beep('sawtooth', 500, .2, .05);
      floatingTexts.push(new FloatingText('ÂøÖÊÆ∫ÊäÄ!', player.x, player.y-30));
    }

    class Invader{ constructor(x,y,row){ this.x=x; this.y=y; this.w=30; this.h=22; this.row=row; this.alive=true; this.anim=0; this.value= [30,30,20,20,10][row] || 10; }
      draw(){ if(!this.alive) return; ctx.save(); ctx.translate(this.x, this.y); this.anim+=0.08; const t=this.anim; ctx.fillStyle = ['#8aa0ff','#8aa0ff','#66e6ff','#66e6ff','#98ffcc'][this.row]||'#98ffcc';
        const up = Math.sin(t)>0;
        const w=this.w, h=this.h;
        ctx.fillRect(-w/2, -h/2, w, 6);
        ctx.fillRect(-w/2+ (up?4:2), -h/2+6, w-(up?8:4), 6);
        ctx.fillRect(-w/2+ (up?10:8), -h/2+12, w-(up?20:16), 6);
        ctx.restore(); }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    class Shield{ constructor(x,y){ this.x=x; this.y=y; this.cell=8; this.cols=12; this.rows=6; this.grid=Array.from({length:this.rows},()=>Array(this.cols).fill(2)); }
      hit(px,py){ const lx = Math.floor((px - (this.x - this.cols*this.cell/2))/this.cell); const ly = Math.floor((py - (this.y - this.rows*this.cell/2))/this.cell); if(lx<0||ly<0||lx>=this.cols||ly>=this.rows) return false; if(this.grid[ly][lx]>0){ this.grid[ly][lx]--; return true; } return false; }
      draw(){ ctx.save(); ctx.translate(this.x - this.cols*this.cell/2, this.y - this.rows*this.cell/2); for(let r=0;r<this.rows;r++) for(let c=0;c<this.cols;c++){ const hp=this.grid[r][c]; if(hp<=0) continue; ctx.globalAlpha=hp===2?1:0.55; ctx.fillStyle='#7bffb9'; ctx.fillRect(c*this.cell, r*this.cell, this.cell-1, this.cell-1);} ctx.globalAlpha=1; ctx.restore(); }
    }

    class UFO{ constructor(){ this.w=50; this.h=22; this.y=72; this.x = Math.random()<0.5? -60 : W+60; this.vx = this.x<0? rand(110,160) : -rand(110,160); this.alive=true; this.points= choice([50,100,150,300]); }
      update(dt){ this.x += this.vx*dt; if(this.x<-100||this.x>W+100) this.alive=false; }
      draw(){ if(!this.alive) return; ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle='#ff6d7a'; ctx.fillRect(-24,-6,48,12); ctx.fillRect(-16,-10,32,8); ctx.fillStyle='#ffd1d6'; ctx.fillRect(-6,-14,12,6); ctx.restore(); }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    // Power-up class
    class PowerUp{
      constructor(x, y, type){
        this.x = x;
        this.y = y;
        this.w = 24;
        this.h = 24;
        this.type = type; // 'rapid', 'multi', 'shield'
        this.vy = 60;
        this.dead = false;
        this.pulse = 0;
      }
      update(dt){
        this.y += this.vy * dt;
        this.pulse += dt * 5;
        if(this.y > H + 30) this.dead = true;
      }
      draw(){
        ctx.save();
        ctx.translate(this.x, this.y);
        const scale = 1 + Math.sin(this.pulse) * 0.1;
        ctx.scale(scale, scale);
        
        // Draw power-up icon based on type
        if(this.type === 'rapid'){
          ctx.fillStyle = '#ff9d42';
          ctx.fillRect(-10, -4, 4, 8);
          ctx.fillRect(-2, -4, 4, 8);
          ctx.fillRect(6, -4, 4, 8);
        } else if(this.type === 'multi'){
          ctx.fillStyle = '#42c3ff';
          ctx.fillRect(-8, -8, 3, 16);
          ctx.fillRect(-1.5, -8, 3, 16);
          ctx.fillRect(5, -8, 3, 16);
        } else if(this.type === 'shield'){
          ctx.fillStyle = '#42ff88';
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.lineTo(-10, -3);
          ctx.lineTo(-10, 6);
          ctx.lineTo(0, 10);
          ctx.lineTo(10, 6);
          ctx.lineTo(10, -3);
          ctx.closePath();
          ctx.fill();
        }
        
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = ctx.fillStyle;
        ctx.fill();
        
        ctx.restore();
      }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    // ===== World containers =====
    let player; let invaders=[]; let bullets=[]; let enemyBullets=[]; let shields=[]; let ufo=null; let invDir=1; let invSpeed=32; let invStepDown=18; let fireTimer=0; let ufoTimer=rand(12,24);
    let powerUps = [];
    let powerUpTimer = rand(8, 15);

    function setupLevel(){
      invaders.length=0; bullets.length=0; enemyBullets.length=0; ufo=null;
      const cols=11, rows=5; const startX=120, gapX=64, startY=120, gapY=40;
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        invaders.push(new Invader(startX + c*gapX, startY + r*gapY, r));
      }
      invDir=1; invSpeed= 28 + (level-1)*4; // „É¨„Éô„É´„ÅßÂ∞ë„ÅóÈÄü„Åè
      const y=H-140; shields=[ new Shield(W*0.2,y), new Shield(W*0.5,y), new Shield(W*0.8,y) ];
    }

    function startGame(){
      state='playing'; score=0; level=1; lives=3; specialAvailable=true;
      player = new Player(); setupLevel(); updateHUD(); hideAllPanels();
      if(audio.state!=='running') audio.resume();
    }

    function nextLevel(){ level++; invSpeed += 6; setupLevel(); updateHUD(); }

    function restart(){ state='title'; hideAllPanels(); titleScreen.classList.remove('hidden'); }

    function gameOver(){
      state='gameover'; hiscore = Math.max(hiscore, score); localStorage.setItem('inv_hi', String(hiscore)); updateHUD();
      document.getElementById('final-score').textContent = String(score);
      document.getElementById('final-hiscore').textContent = String(hiscore);
      hideAllPanels(); overScreen.classList.remove('hidden');
    }

    function togglePause(){ if(state==='playing'){ state='paused'; pausedScreen.classList.remove('hidden'); } else if(state==='paused'){ state='playing'; pausedScreen.classList.add('hidden'); } }

    function hideAllPanels(){ titleScreen.classList.add('hidden'); overScreen.classList.add('hidden'); pausedScreen.classList.add('hidden'); }

    // ===== Collision & helpers =====
    function overlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    function bottomInvadersByColumn(){
      const byCol = new Map();
      for(const inv of invaders){ if(!inv.alive) continue; const col = Math.round((inv.x-120)/64); const prev = byCol.get(col); if(!prev || inv.y>prev.y) byCol.set(col, inv); }
      return Array.from(byCol.values());
    }

    // ===== Main Loop =====
    let last=0;
    function loop(ts){
      const now=ts||0; const dt = Math.min(0.033,(now - last)/1000||0); last=now; if(state==='playing') update(dt); draw(); requestAnimationFrame(loop);
    }

    function update(dt){
      player.update(dt);
      
      // Combo timer
      if(comboTimer > 0){
        comboTimer -= dt;
        if(comboTimer <= 0){
          combo = 0;
        }
      }
      
      // Power-up spawning
      powerUpTimer -= dt;
      if(powerUpTimer <= 0 && Math.random() < 0.4){
        const types = ['rapid', 'multi', 'shield'];
        const type = choice(types);
        powerUps.push(new PowerUp(rand(50, W-50), -30, type));
        powerUpTimer = rand(10, 20);
      }
      
      // Update power-ups
      for(const p of powerUps) p.update(dt);

      // Invader marching
      const alive = invaders.filter(i=>i.alive);
      if(alive.length===0){ beep('sawtooth',600,.12,.03); nextLevel(); return; }

      // bounds of alive invaders
      let minX=Infinity, maxX=-Infinity, maxY=-Infinity;
      for(const i of alive){ if(i.x<minX) minX=i.x; if(i.x>maxX) maxX=i.x; if(i.y>maxY) maxY=i.y; }
      const edgeLeft = (minX-30) <= 10;
      const edgeRight = (maxX+30) >= (W-10);
      if((edgeLeft && invDir<0) || (edgeRight && invDir>0)){ invDir*=-1; for(const i of alive){ i.y += invStepDown; } invSpeed += 6; beep('triangle',220,.05,.008); }
      for(const i of alive){ i.x += invDir * invSpeed * dt; }

      // Enemy fire
      fireTimer -= dt;
      if(fireTimer<=0){
        const bottoms = bottomInvadersByColumn();
        if(bottoms.length){ const shooter = choice(bottoms); enemyBullets.push(new Bullet(shooter.x, shooter.y+16, rand(160,220), 'enemy')); beep('sine', 220, .05, .01); }
        fireTimer = clamp(1.1 - level*0.05, 0.3, 1.1);
      }

      // UFO spawn
      ufoTimer -= dt; if(ufoTimer<=0 && !ufo){ ufo = new UFO(); beep('sawtooth', 520, .08, .018); ufoTimer = rand(16, 28); }
      if(ufo){ ufo.update(dt); if(!ufo.alive) ufo=null; }

      // Bullets
      for(const b of bullets) b.update(dt);
      for(const b of enemyBullets) b.update(dt);

      // Player bullets vs invaders/UFO/shields
      for(const b of bullets){ if(b.dead) continue; const br=b.rect();
        for(const inv of invaders){ if(!inv.alive) continue; if(overlap(br, inv.rect())){ 
          inv.alive=false; b.dead=true; 
          
          // Combo system
          combo++;
          comboTimer = 1.5; // 1.5 seconds to maintain combo
          const comboMultiplier = Math.min(combo, 10);
          const points = inv.value * comboMultiplier;
          score += points;
          updateHUD();
          
          // Show combo feedback
          if(combo > 1){
            const comboText = combo >= 10 ? `MAX COMBO x${comboMultiplier}!` : `x${comboMultiplier} COMBO`;
            floatingTexts.push(new FloatingText(comboText, inv.x, inv.y - 20));
            floatingTexts.push(new FloatingText(`+${points}`, inv.x, inv.y));
            const pitch = 300 + combo * 50;
            beep('square', Math.min(pitch, 800), .06, .02);
          } else {
            beep('square', 300, .06, .02);
          }
          
          // Create explosion for invader
          const colors = ['#8aa0ff','#8aa0ff','#66e6ff','#66e6ff','#98ffcc'];
          createExplosion(inv.x, inv.y, colors[inv.row] || '#98ffcc', 15 + combo);
          break; 
        }}
        if(!b.dead){ for(const sh of shields){ if(sh.hit(b.x, b.y)){ b.dead=true; break; } } }
        if(!b.dead && ufo){ if(overlap(br, ufo.rect())){ 
          combo = 0; // UFO resets combo but gives big points
          score+=ufo.points; updateHUD(); 
          floatingTexts.push(new FloatingText(`+${ufo.points}`, ufo.x, ufo.y-10)); 
          ufo.alive=false; b.dead=true; 
          beep('square', 900, .09, .03);
          // Create bigger explosion for UFO
          createExplosion(ufo.x, ufo.y, '#ff6d7a', 25);
        }}
      }

      // Enemy bullets vs player/shields
      for(const b of enemyBullets){ if(b.dead) continue; const br=b.rect();
        for(const sh of shields){ if(sh.hit(b.x, b.y)){ b.dead=true; break; } }
        if(b.dead) continue;
        if(overlap(br, player.rect())){ b.dead=true; lives--; updateHUD(); beep('triangle',120,.12,.02); screenFlash(); if(lives<=0) return gameOver(); player.x=W/2; enemyBullets = enemyBullets.filter(bb=>bb.y < player.y-40); }
      }

      // Player vs power-ups
      for(const p of powerUps){
        if(p.dead) continue;
        if(overlap(p.rect(), player.rect())){
          p.dead = true;
          
          if(p.type === 'shield'){
            // Repair shields
            for(const sh of shields){
              for(let r = 0; r < sh.rows; r++){
                for(let c = 0; c < sh.cols; c++){
                  if(sh.grid[r][c] < 2) sh.grid[r][c] = 2;
                }
              }
            }
            floatingTexts.push(new FloatingText('SHIELDS REPAIRED!', player.x, player.y - 40));
            beep('sawtooth', 1000, .1, .03);
          } else {
            player.powerUp = p.type;
            player.powerUpTime = 8; // 8 seconds duration
            const text = p.type === 'rapid' ? 'RAPID FIRE!' : 'MULTI-SHOT!';
            floatingTexts.push(new FloatingText(text, player.x, player.y - 40));
            beep('sawtooth', 1200, .1, .03);
          }
        }
      }
      
      bullets = bullets.filter(b=>!b.dead);
      enemyBullets = enemyBullets.filter(b=>!b.dead);
      powerUps = powerUps.filter(p=>!p.dead);

      // Lose when invaders reach player lineÔºà„Éó„É¨„Éº„É§„Éº‰ΩçÁΩÆ‰ªòËøëÔºâ
      if(maxY >= player.y - 10){ gameOver(); }

      // Floating texts
      for(const ft of floatingTexts) ft.update(dt);
      floatingTexts = floatingTexts.filter(t=>!t.dead);
      
      // Particles
      for(const p of particles) p.update(dt);
      particles = particles.filter(p => p.life > 0);
    }

    // Simple flash on damage
    let flashT=0; function screenFlash(){ flashT=0.18; }

    // Floating text
    class FloatingText{ constructor(text,x,y){ this.text=text; this.x=x; this.y=y; this.t=0; this.dead=false; }
      update(dt){ this.t+=dt; this.y-=30*dt; if(this.t>0.8) this.dead=true; }
      draw(){ ctx.globalAlpha = 1 - this.t/0.8; ctx.fillStyle='#fff2b3'; ctx.font='700 18px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha=1; }
    }
    let floatingTexts=[];

    // Particle system for explosions
    class Particle{
      constructor(x, y, color){
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 280;
        this.vy = (Math.random() - 0.5) * 280;
        this.life = 1;
        this.color = color;
        this.size = Math.random() * 4 + 2;
      }
      update(dt){
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life -= dt * 2;
        if(this.life <= 0) this.life = 0;
      }
      draw(){
        if(this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        const size = this.size * this.life;
        ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
        // Glow effect
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x - size/4, this.y - size/4, size/2, size/2);
        ctx.restore();
      }
    }
    
    let particles = [];
    
    function createExplosion(x, y, color, count = 12){
      for(let i = 0; i < count; i++){
        particles.push(new Particle(x, y, color));
      }
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      drawStars();
      for(const sh of shields) sh.draw();
      for(const p of powerUps) p.draw();
      if(player) player.draw();
      for(const i of invaders) i.draw();
      for(const b of bullets) b.draw();
      for(const b of enemyBullets) b.draw();
      if(ufo) ufo.draw();
      for(const p of particles) p.draw();
      for(const ft of floatingTexts) ft.draw();
      if(flashT>0){ ctx.fillStyle='rgba(255,255,255,'+flashT.toFixed(2)+')'; ctx.fillRect(0,0,W,H); flashT-=0.016; }
    }

    // Starfield backdrop
    const stars = Array.from({length:130},()=>({x:Math.random()*W, y:Math.random()*H, s: Math.random()*1.5+0.5}));
    function drawStars(){
      ctx.save();
      for(const st of stars){ st.y+= st.s*0.4; if(st.y>H) st.y=0; ctx.globalAlpha = clamp(0.5 + st.s/2, 0.5, 1); ctx.fillStyle='#bac6ff'; ctx.fillRect(st.x, st.y, 2, 2); }
      ctx.globalAlpha=1; ctx.restore();
    }

    // --- Self-tests (run once on load; see console) ---
    function runSelfTests(){
      const results=[]; let passed=0; const assert=(name, cond)=>{ console.assert(cond, 'FAIL:', name); if(cond){passed++; results.push('‚úî '+name);} else { results.push('‚úñ '+name);} };
      try{
        // Test 1: Shield.draw doesn't throw (typo regression)
        const sh = new Shield(100,100);
        try{ sh.draw(); assert('Shield.draw executes without ReferenceError', true); }catch(e){ assert('Shield.draw executes without ReferenceError', false); console.error(e); }

        // Test 2: Shield.hit depletes correctly (2 ‚Üí 1 ‚Üí 0)
        const px=sh.x, py=sh.y;
        const hit1=sh.hit(px,py); const hit2=sh.hit(px,py); const hit3=sh.hit(px,py);
        assert('Shield.hit returns true, true, then false', hit1 && hit2 && !hit3);

        // Test 3: Special attack adds 7 wide bullets and locks
        const savedState=state, savedBulletsLen=bullets.length, savedPlayer=player, savedSpecial=specialAvailable;
        state='playing'; player=new Player(); player.x=W/2; specialAvailable=true;
        const before=bullets.length; useSpecial(); const after=bullets.length; const added=after-before;
        const widthsOK = bullets.slice(-added).every(b=>b.w>=6);
        assert('useSpecial adds exactly 7 wide bullets once', added===7 && widthsOK && specialAvailable===false);
        // cleanup
        bullets.length=savedBulletsLen; player=savedPlayer; specialAvailable=savedSpecial; state=savedState;

        // Test 4: Game over when invader reaches player line
        state='playing'; player=new Player(); invaders=[new Invader(200, player.y-20, 0)]; shields=[]; bullets=[]; enemyBullets=[];
        update(0); assert('Invaders above player line do NOT end game', state==='playing');
        invaders[0].y = player.y - 5; update(0); assert('Invaders reaching player line DO end game', state==='gameover');
        state='title';
      }catch(e){ console.error('Self-tests crashed', e); }
      console.groupCollapsed('Invaders self-tests'); results.forEach(r=>console.log(r)); console.log(`${passed}/${results.length} tests passed`); console.groupEnd();
    }

    // Buttons
    document.getElementById('btn-start').addEventListener('click', startGame);
    document.getElementById('btn-restart').addEventListener('click', ()=>{ restart(); startGame(); });

    // Prevent page scroll on space/arrow
    window.addEventListener('keydown', e=>{ if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); }, {passive:false});

    // Debug helpers
    window.__invaders__ = { mute(v){ muted=!!v; }, resetHi(){ localStorage.removeItem('inv_hi'); hiscore=0; updateHUD(); }, giveSpecial(){ specialAvailable=true; } };

    updateHUD();

    // Run tests, then start loop
    runSelfTests();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
