<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>スペースインベーダー - モバイル版</title>
  <style>
    :root { --bg:#0b0f1a; --fg:#f2f5ff; --accent:#42ff88; --muted:#8aa0ff; }
    html,body{height:100%;}
    body{margin:0; background:radial-gradient(1200px 600px at 50% -200px,#101426 0%, #0b0f1a 60%, #070a12 100%); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "メイリオ", Meiryo, "Apple Color Emoji", "Segoe UI Emoji";}
    #wrap{position:relative; width:100vw; height:100vh; margin:0; display:flex; flex-direction:column;}
    canvas{display:block; background:transparent; touch-action:none;}
    
    /* Desktop layout */
    @media (min-width: 769px) {
      #wrap{justify-content:center; align-items:center;}
      canvas{width:100%; max-width:960px; height:auto; max-height:calc(100vh - 140px);}
    }
    
    /* Mobile and tablet layout - Split screen */
    @media (max-width: 768px) {
      #wrap{padding:0; height:100vh; display:flex; flex-direction:column;}
      
      /* Game area takes 70% of screen */
      .game-area{
        flex:0 0 70vh;
        position:relative;
        display:flex;
        justify-content:center;
        align-items:center;
        background:#0b0f1a;
      }
      
      canvas{
        width:100%;
        height:100%;
        object-fit:contain;
        max-width:100vw;
        max-height:70vh;
      }
      
      /* HUD overlay on game area */
      .hud{position:absolute; top:0; left:0; right:0; height:60px; z-index:10;}
      .hud .row{padding:5px 8px; font-size:14px; background:rgba(11,15,26,0.8);}
      
      /* Control area takes 30% of screen */
      .control-area{
        flex:0 0 30vh;
        background:linear-gradient(to bottom, rgba(11,15,26,0.95), #1a1f2e);
        display:flex;
        align-items:center;
        justify-content:center;
        padding:10px;
      }
    }
    .hud{position:absolute; inset:0; pointer-events:none;}
    .row{display:flex; justify-content:space-between; align-items:center; gap:8px; padding:10px 12px; font-weight:700; letter-spacing:.02em; text-shadow:0 2px 12px rgba(0,0,0,.45)}
    .score, .lives, .level{font-variant-numeric:tabular-nums;}
    .pill{display:inline-block; padding:.25rem .5rem; border-radius:9999px; background:rgba(255,255,255,.06); box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);}
    .center{position:absolute; inset:0; display:grid; place-items:center;}
    .panel{pointer-events:auto; text-align:center; background:rgba(6,10,18,.74); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:22px 24px; backdrop-filter: blur(8px); box-shadow:0 10px 40px rgba(0,0,0,.35); z-index:1000;}
    .panel h1{margin:.1rem 0 0.35rem; font-size:clamp(24px, 5vw, 40px); letter-spacing:.04em;}
    .panel p{margin:.4rem 0; color:#c8d0ff; font-size:clamp(12px, 2.8vw, 16px)}
    .kbd{display:inline-block; min-width:1.6em; text-align:center; padding:.18rem .45rem; border-radius:8px; background:#0d1322; border:1px solid rgba(255,255,255,.14); box-shadow: inset 0 -2px 0 rgba(255,255,255,.06), 0 4px 16px rgba(0,0,0,.35);}
    .btn{pointer-events:auto; cursor:pointer; margin-top:.6rem; display:inline-block; background:linear-gradient(180deg,#2ef29f,#19ce85); color:#02120a; font-weight:800; border:none; padding:.6rem 1rem; border-radius:12px; box-shadow:0 10px 30px rgba(23, 232, 142, .45); position:relative; z-index:1001; text-decoration:none; user-select:none; -webkit-user-select:none;}
    .tiny{font-size:12px; opacity:.85}
    .hidden{display:none}
    .mobile-only{display:none}
    @media (pointer:coarse), (max-width:768px){
      .mobile-only{display:block}
      .desktop-only{display:none}
    }
    
    /* Mobile controls - Responsive design */
    .mobile-controls{display:none; pointer-events:auto; user-select:none; -webkit-user-select:none;}
    
    @media (max-width: 768px) {
      .mobile-controls{
        display:flex; 
        align-items:center;
        justify-content:center;
        gap:20px;
        width:100%;
        max-width:500px;
        padding:0 20px;
      }
      
      .mobile-btn{
        border-radius:15px; 
        background:rgba(255,255,255,0.2); 
        border:3px solid rgba(255,255,255,0.4); 
        display:grid; 
        place-items:center; 
        color:var(--fg); 
        touch-action:none; 
        transition:all 0.15s;
        box-shadow:0 4px 12px rgba(0,0,0,0.4);
        font-weight:bold;
      }
      
      .mobile-btn:active{
        background:rgba(255,255,255,0.4); 
        transform:scale(0.92); 
        box-shadow:0 2px 20px rgba(255,255,255,0.5);
      }
      
      /* Left arrow button */
      .mobile-left{
        width:80px; 
        height:80px; 
        font-size:36px;
        background:linear-gradient(135deg, rgba(74,144,226,0.3), rgba(74,144,226,0.15));
        border-color:#4a90e2;
      }
      
      /* Fire button - largest in center */
      .mobile-fire{
        width:120px; 
        height:120px; 
        background:linear-gradient(135deg, rgba(66,255,136,0.4), rgba(66,255,136,0.2)); 
        border-color:var(--accent); 
        font-size:48px;
        box-shadow:0 6px 20px rgba(66,255,136,0.4);
      }
      
      /* Right arrow button */
      .mobile-right{
        width:80px; 
        height:80px; 
        font-size:36px;
        background:linear-gradient(135deg, rgba(74,144,226,0.3), rgba(74,144,226,0.15));
        border-color:#4a90e2;
      }
      
      /* Pause button - smaller in top corner */
      .mobile-pause{
        position:absolute;
        top:10px;
        right:10px;
        width:50px; 
        height:50px; 
        font-size:18px;
        background:rgba(255,255,255,0.15);
        border-color:rgba(255,255,255,0.3);
      }
    }
    
    /* Tablet controls */
    @media (min-width: 481px) and (max-width: 768px) {
      .mobile-btn{width:80px; height:80px; font-size:28px;}
      .mobile-fire{width:100px; height:100px; font-size:36px;}
      .mobile-special{width:65px; height:65px; font-size:22px;}
      .mobile-pause{width:60px; height:60px; font-size:20px;}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <!-- Game Area (70% of screen on mobile) -->
    <div class="game-area">
      <canvas id="game" width="960" height="600" aria-label="インベーダーゲーム"></canvas>
      <div class="hud" aria-hidden="true">
        <div class="row">
          <div class="score">SCORE: <span id="score">0000</span></div>
          <div class="pill">HIGH: <span id="hiscore">0000</span></div>
          <div class="level">LEVEL: <span id="level">1</span></div>
          <div class="lives">LIVES: <span id="lives">5</span></div>
        </div>
        <div class="center">
          <div id="screen-title" class="panel">
            <h1>SPACE INVADERS</h1>
            <h1 style="font-size:20px; color:#42ff88; margin-top:-10px;">モバイル版</h1>
            <div class="mobile-only" style="margin:15px 0;">
              <p style="font-size:18px; color:#42c3ff;">📱 タッチ操作</p>
              <p>◀▶ 移動 | 🚀 発射</p>
            </div>
            <div class="desktop-only">
              <p><span class="kbd">←</span> / <span class="kbd">→</span> または <span class="kbd">A</span> / <span class="kbd">D</span>：移動　　<span class="kbd">SPACE</span>：ショット</p>
              <p><span class="kbd">P</span>：一時停止　　<span class="kbd">R</span>：やり直し</p>
            </div>
            <p class="tiny">時々、上空に<span style="color:var(--accent); font-weight:800;">UFO</span>が出現！ 撃墜で高得点！</p>
            <p class="tiny"><span style="color:#ff9d42;">パワーアップ</span>を集めて強くなろう！</p>
            <button id="btn-start" class="btn">ゲーム開始</button>
            <button id="btn-tutorial" class="btn" style="background:linear-gradient(180deg,#42c3ff,#2a9dd6); margin-left:10px;">遊び方</button>
          </div>
          <div id="screen-gameover" class="panel hidden">
            <h1>GAME OVER</h1>
            <p>スコア：<span id="final-score">0</span>　ハイスコア：<span id="final-hiscore">0</span></p>
            <button id="btn-restart" class="btn">もう一度（R）</button>
          </div>
          <div id="screen-paused" class="panel hidden">
            <h1>一時停止中</h1>
            <p style="font-size: 18px; margin: 15px 0;">ゲームが一時停止されています</p>
            <p class="desktop-only">再開するには <span class="kbd">P</span> キーを押してください</p>
            <p class="mobile-only">⏸️ ボタンをタップして再開</p>
            <p class="tiny" style="margin-top: 20px;">または <span class="kbd">ESC</span> でタイトルに戻る</p>
          </div>
          <div id="screen-tutorial" class="panel hidden">
            <h1>🎮 遊び方</h1>
            <div style="text-align:left; max-width:400px; margin:0 auto;">
              <p style="margin:10px 0;"><strong>目標:</strong> すべての侵略者を倒そう！</p>
              <p style="margin:10px 0;"><strong>操作:</strong></p>
              <ul style="margin:10px 0; padding-left:20px;">
                <li>◀▶ で左右に移動</li>
                <li>🚀 でミサイル発射</li>
              </ul>
              <p style="margin:10px 0;"><strong>パワーアップ:</strong></p>
              <ul style="margin:10px 0; padding-left:20px;">
                <li><span style="color:#ff9d42;">🔥</span> 連射速度アップ</li>
                <li><span style="color:#42c3ff;">💫</span> 3方向ショット</li>
                <li><span style="color:#42ff88;">🛡️</span> シールド修復</li>
              </ul>
              <p style="margin:10px 0;"><strong>ヒント:</strong> UFOを狙って高得点！</p>
            </div>
            <button id="btn-tutorial-close" class="btn">閉じる</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Control Area (30% of screen on mobile) -->
    <div class="control-area">
      <div class="mobile-controls">
        <button class="mobile-btn mobile-left" id="mobile-left" aria-label="左移動">◀</button>
        <button class="mobile-btn mobile-fire" id="mobile-fire" aria-label="発射">🚀</button>
        <button class="mobile-btn mobile-right" id="mobile-right" aria-label="右移動">▶</button>
      </div>
      <button class="mobile-btn mobile-pause" id="mobile-pause" aria-label="一時停止">⏸️</button>
    </div>
  </div>

  <script>
  (()=>{
    // ===== Utility =====
    const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
    const rand=(a,b)=>Math.random()*(b-a)+a;
    const choice=arr=>arr[(Math.random()*arr.length)|0];

    // Responsive canvas system
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let gameScale = 1;
    let canvasWidth, canvasHeight;
    
    function setupCanvas(){
      // Always use standard game dimensions
      canvas.width = 960;
      canvas.height = 600;
      
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const isMobileDevice = viewportWidth <= 768;
      
      if(isMobileDevice) {
        // Mobile: Use 70% of screen height for game area
        const gameAreaHeight = viewportHeight * 0.7;
        const gameAreaWidth = viewportWidth;
        
        // Calculate scale to fit game area perfectly
        const scaleX = gameAreaWidth / 960;
        const scaleY = gameAreaHeight / 600;
        gameScale = Math.min(scaleX, scaleY);
        
        // Canvas takes full game area
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        
        console.log('Mobile canvas setup - Split layout:', { 
          viewport: { w: viewportWidth, h: viewportHeight },
          gameArea: { w: gameAreaWidth, h: gameAreaHeight },
          gameScale
        });
      } else {
        // Desktop: Standard scaling
        gameScale = 1;
        canvas.style.width = '100%';
        canvas.style.height = 'auto';
        canvas.style.maxWidth = '960px';
        canvas.style.maxHeight = '600px';
      }
      
      // Reset context transform
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    
    // Setup canvas on load and resize
    window.addEventListener('resize', setupCanvas);
    window.addEventListener('orientationchange', setupCanvas);
    setupCanvas();

    // ===== Game State =====
    const W=960, H=600;
    canvas.style.aspectRatio = `${W}/${H}`;
    
    // Mobile detection (moved up)
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                     ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    
    // Mobile optimization - reduce particles on mobile
    const MAX_PARTICLES = isMobile ? 200 : 500;
    const PARTICLE_COUNT = isMobile ? 8 : 12;

    let state='title';
    let score=0, hiscore= Number(localStorage.getItem('inv_hi')||0), level=1, lives=5;
    let isDemo = false; // Demo play mode flag
    let demoTimer = 0; // Timer for starting demo
    const DEMO_START_DELAY = 10; // Start demo after 10 seconds of inactivity
    
    // Student progress tracking
    let sessionStats = {
      startTime: Date.now(),
      enemiesDestroyed: 0,
      powerUpsCollected: 0,
      highestLevel: 1
    };
    let combo = 0;
    let comboTimer = 0;
    let waveTransition = false;
    let waveTransitionTimer = 0;
    let isBossLevel = false;
    
    // Achievement system
    let achievements = JSON.parse(localStorage.getItem('space_invaders_achievements') || '{}');

    // HUD hooks
    const $ = sel => document.querySelector(sel);
    const scrEl = $('#score');
    const hiEl  = $('#hiscore');
    const lvEl  = $('#level');
    const livesEl = $('#lives');
    const titleScreen = $('#screen-title');
    const overScreen = $('#screen-gameover');
    const pausedScreen = $('#screen-paused');

    function updateHUD(){
      scrEl.textContent = score.toString().padStart(4,'0');
      hiEl.textContent  = hiscore.toString().padStart(4,'0');
      lvEl.textContent  = level;
      livesEl.textContent = lives;
    }
    
    // Achievement checking
    const achievementList = {
      'first_kill': { name: '初撃破', desc: '初めて敵を倒した', icon: '🎯' },
      'combo_master': { name: 'コンボマスター', desc: '10連続コンボを達成', icon: '🔥' },
      'boss_slayer': { name: 'ボス討伐者', desc: 'ボスを倒した', icon: '👑' },
      'power_collector': { name: 'パワーアップ収集家', desc: 'パワーアップを10個取得', icon: '💎' },
      'survivor': { name: 'サバイバー', desc: 'レベル10に到達', icon: '🛡️' },
      'high_scorer': { name: 'ハイスコアラー', desc: '10000点を獲得', icon: '⭐' }
    };
    
    function checkAchievement(key) {
      if(achievements[key]) return; // Already unlocked
      
      let unlock = false;
      switch(key) {
        case 'first_kill':
          unlock = sessionStats.enemiesKilled >= 1;
          break;
        case 'combo_master':
          unlock = sessionStats.maxCombo >= 10;
          break;
        case 'boss_slayer':
          unlock = sessionStats.bossesDefeated >= 1;
          break;
        case 'power_collector':
          unlock = sessionStats.powerUpsCollected >= 10;
          break;
        case 'survivor':
          unlock = level >= 10;
          break;
        case 'high_scorer':
          unlock = score >= 10000;
          break;
      }
      
      if(unlock) {
        achievements[key] = true;
        localStorage.setItem('space_invaders_achievements', JSON.stringify(achievements));
        const ach = achievementList[key];
        floatingTexts.push(new FloatingText(`🏆 ${ach.name}`, W/2, H/2 - 50));
        beep('sawtooth', 800, .15, .04);
      }
    }
    
    function checkAllAchievements() {
      Object.keys(achievementList).forEach(checkAchievement);
    }

    // ===== Input =====
    const keys = new Set();
    const down = e=>{
      keys.add(e.code);
      
      // Reset demo timer on any key press
      demoTimer = 0;
      
      // If in demo mode, return to title on any key
      if(isDemo) {
        stopDemo();
        return;
      }
      
      if(state==='title' && (e.code==='Enter' || e.code==='Space')) startGame();
      if(e.code==='KeyP') togglePause();
      if(e.code==='KeyR') restart();
      if(e.code==='Escape' && state==='paused') {
        state='title'; 
        hideAllPanels(); 
        titleScreen.classList.remove('hidden');
        stopBGM();
        if(window.nextLevelTimeout) {
          clearTimeout(window.nextLevelTimeout);
          window.nextLevelTimeout = null;
        }
      }
    };
    const up = e=>{ keys.delete(e.code); };
    window.addEventListener('keydown', down);
    window.addEventListener('keyup', up);
    
    // Enhanced Mobile controls (isMobile already defined above)
    
    // Always enable mobile controls on touch devices
    if(isMobile || window.innerWidth <= 768){
      const mobileLeft = document.getElementById('mobile-left');
      const mobileRight = document.getElementById('mobile-right');
      const mobileFire = document.getElementById('mobile-fire');
      const mobilePause = document.getElementById('mobile-pause');
      
      // Touch controls with vibration feedback
      const handleTouch = (el, code, vibration = 10) => {
        el.addEventListener('touchstart', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Initialize audio on first touch (iOS requirement)
          if(!audioInitialized) {
            initializeAudio();
          }
          
          // Vibration feedback if supported
          if('vibrate' in navigator){
            navigator.vibrate(vibration);
          }
          
          // Visual feedback
          el.classList.add('active');
          keys.add(code);
        });
        
        el.addEventListener('touchend', (e) => {
          e.preventDefault();
          e.stopPropagation();
          el.classList.remove('active');
          keys.delete(code);
        });
        
        // Handle touch cancel
        el.addEventListener('touchcancel', (e) => {
          e.preventDefault();
          el.classList.remove('active');
          keys.delete(code);
        });
      };
      
      // Movement controls
      handleTouch(mobileLeft, 'ArrowLeft', 8);
      handleTouch(mobileRight, 'ArrowRight', 8);
      
      // Fire button - stronger vibration
      handleTouch(mobileFire, 'Space', 20);
      
      // Pause button
      if(mobilePause){
        mobilePause.addEventListener('touchstart', (e) => {
          e.preventDefault();
          
          // Initialize audio on first touch (iOS requirement)
          if(!audioInitialized) {
            initializeAudio();
          }
          
          if('vibrate' in navigator) navigator.vibrate(15);
          togglePause();
        });
      }
      
      // Prevent double-tap zoom on all buttons
      document.querySelectorAll('.mobile-btn').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
        });
      });
    }

    // ===== Audio =====
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audio = new AudioCtx();
    let muted = false;
    let bgMusicPlaying = false;
    let currentBgMusic = null;
    let audioInitialized = false;
    let victoryMusicPlaying = false;
    
    // Initialize audio for iOS compatibility
    function initializeAudio(){
      if(audioInitialized) return Promise.resolve();
      
      return audio.resume().then(() => {
        // Play a silent sound to unlock iOS audio
        const osc = audio.createOscillator();
        const gain = audio.createGain();
        gain.gain.value = 0;
        osc.connect(gain);
        gain.connect(audio.destination);
        osc.start();
        osc.stop(audio.currentTime + 0.01);
        
        audioInitialized = true;
        console.log('Audio initialized for iOS');
      }).catch(e => {
        console.warn('Audio initialization failed:', e);
      });
    }
    
    function beep(type='square', freq=440, dur=0.06, gain=0.015){
      if(muted) return;
      
      // Try to initialize audio if not running
      if(audio.state !== 'running' && !audioInitialized) {
        initializeAudio();
        return; // Skip this beep, next one should work
      }
      
      if(audio.state !== 'running') return;
      const t0 = audio.currentTime;
      const o = audio.createOscillator();
      const g = audio.createGain();
      o.type = type; o.frequency.value=freq;
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g).connect(audio.destination);
      o.start(t0); o.stop(t0+dur);
    }
    
    // Victory fanfare for boss defeat
    function playVictoryFanfare() {
      if(muted || audio.state !== 'running') return;
      
      victoryMusicPlaying = true;
      const victoryNotes = [
        // Triumphant ascending melody
        {freq: 523, delay: 0},      // C5
        {freq: 659, delay: 100},    // E5
        {freq: 784, delay: 200},    // G5
        {freq: 1047, delay: 300},   // C6
        {freq: 784, delay: 500},    // G5
        {freq: 1047, delay: 600},   // C6
        {freq: 1319, delay: 700},   // E6
        {freq: 1568, delay: 900},   // G6
        // Finale
        {freq: 1047, delay: 1200},  // C6
        {freq: 784, delay: 1300},   // G5
        {freq: 1047, delay: 1400},  // C6
        {freq: 1319, delay: 1500},  // E6
        {freq: 1568, delay: 1700},  // G6
        {freq: 2093, delay: 1900},  // C7 - Grand finish
      ];
      
      victoryNotes.forEach(note => {
        setTimeout(() => {
          if(!victoryMusicPlaying) return;
          beep('square', note.freq, .15, .05);
          beep('sine', note.freq/2, .12, .04);
          if(note.freq > 1000) {
            beep('triangle', note.freq * 1.5, .08, .03);
          }
        }, note.delay);
      });
      
      // Stop after fanfare
      setTimeout(() => {
        victoryMusicPlaying = false;
      }, 2500);
    }
    
    // Simple background music using oscillators
    function playBGM(type = 'normal'){
      if(muted || audio.state !== 'running' || bgMusicPlaying || !audioInitialized) return;
      
      bgMusicPlaying = true;
      const melody = type === 'boss' ? 
        [220, 196, 174, 196, 220, 196, 174, 164] : // Boss theme
        [330, 294, 262, 294, 330, 294, 262, 247]; // Normal theme
      
      let noteIndex = 0;
      const playNote = () => {
        if(!bgMusicPlaying || state === 'gameover' || state === 'title') return;
        
        try {
          const freq = melody[noteIndex % melody.length];
          const osc = audio.createOscillator();
          const gain = audio.createGain();
          
          osc.type = 'square';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0.003, audio.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.0001, audio.currentTime + 0.4);
          
          osc.connect(gain).connect(audio.destination);
          osc.start();
          osc.stop(audio.currentTime + 0.4);
          
          noteIndex++;
          if(bgMusicPlaying) {
            currentBgMusic = setTimeout(playNote, 500);
          }
        } catch(e) {
          console.warn('BGM playback error:', e);
          stopBGM();
        }
      };
      
      playNote();
    }
    
    function stopBGM(){
      bgMusicPlaying = false;
      if(currentBgMusic) {
        clearTimeout(currentBgMusic);
        currentBgMusic = null;
      }
    }
    
    window.addEventListener('pointerdown', ()=>{ if(audio.state!=='running') audio.resume(); }, {once:true});

    // ===== Entities =====
    class Bullet{
      constructor(x,y,vy,from,w=3,h=10){this.x=x; this.y=y; this.vy=vy; this.w=w; this.h=h; this.from=from; this.dead=false; this.vx=0;}
      update(dt){ 
        this.x += this.vx*dt;
        this.y += this.vy*dt; 
        if(this.y<-40||this.y>H+40||this.x<-40||this.x>W+40) this.dead=true; 
      }
      draw(){ 
        const size = 1.5; // Always larger for better visibility
        const w = this.w * size;
        const h = this.h * size;
        
        ctx.fillStyle = this.from==='player'? '#42ff88' : '#ff8a8a'; 
        ctx.fillRect(this.x-w/2, this.y-h/2, w, h);
        
        // Add glow effect for better visibility
        ctx.shadowBlur = 5 * size;
        ctx.shadowColor = this.from==='player'? '#42ff88' : '#ff8a8a';
        ctx.fillRect(this.x-w/2, this.y-h/2, w, h);
        ctx.shadowBlur = 0;
      }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    class Player{
      constructor(){ 
        this.x=W/2; this.y=H-60; this.w=40; this.h=22; this.speed=320; this.cool=0; 
        this.powerUp = null;
        this.powerUpTime = 0;
        this.invulnerable = 0; // Invulnerability time after hit
      }
      update(dt){
        const left = keys.has('ArrowLeft')||keys.has('KeyA');
        const right = keys.has('ArrowRight')||keys.has('KeyD');
        let ax = (right?1:0) - (left?1:0);
        this.x += ax * this.speed * dt;
        this.x = clamp(this.x, 24, W-24);
        this.cool -= dt;
        
        // Invulnerability timer
        if(this.invulnerable > 0) {
          this.invulnerable -= dt;
        }
        
        // Power-up timer
        if(this.powerUp && this.powerUpTime > 0){
          this.powerUpTime -= dt;
          if(this.powerUpTime <= 0){
            this.powerUp = null;
            floatingTexts.push(new FloatingText('Power-up expired', this.x, this.y - 40));
          }
        }
        
        // Shooting with power-ups
        const maxBullets = this.powerUp === 'rapid' ? 5 : 2;
        const cooldown = this.powerUp === 'rapid' ? 0.06 : 0.12;
        
        if(keys.has('Space') && this.cool<=0 && bullets.filter(b=>b.from==='player').length<maxBullets){
          if(this.powerUp === 'multi'){
            // Triple shot
            bullets.push(new Bullet(this.x, this.y-18, -480, 'player'));
            bullets.push(new Bullet(this.x-12, this.y-18, -480, 'player'));
            bullets.push(new Bullet(this.x+12, this.y-18, -480, 'player'));
          } else {
            bullets.push(new Bullet(this.x, this.y-18, -480, 'player'));
          }
          this.cool = cooldown;
          beep('square', 880, .06, .02);
        }
      }
      draw(){
        if(!this) return;
        
        ctx.save(); 
        ctx.translate(this.x, this.y);
        
        // Invulnerability flashing
        if(this.invulnerable > 0 && Math.sin(Date.now() * 0.02) > 0) {
          ctx.globalAlpha = 0.5;
        }
        
        // Power-up aura
        if(this.powerUp){
          ctx.save();
          const auraColor = this.powerUp === 'rapid' ? '#ff9d42' : 
                           this.powerUp === 'multi' ? '#42c3ff' : '#42ff88';
          ctx.strokeStyle = auraColor;
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
          ctx.strokeRect(-24, -12, 48, 26);
          ctx.restore();
        }
        
        // Draw larger, more visible player ship
        const size = 1.5; // Always larger for better visibility
        
        // Main body - bright cyan
        ctx.fillStyle = '#00ffff';
        ctx.fillRect(-25*size, 8*size, 50*size, 8*size);   // Bottom part (wider)
        ctx.fillRect(-15*size, 0*size, 30*size, 10*size);  // Middle part  
        ctx.fillRect(-6*size, -10*size, 12*size, 20*size); // Top part (taller)
        
        // Bright white outline for maximum visibility
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2*size;
        ctx.strokeRect(-25*size, 8*size, 50*size, 8*size);
        ctx.strokeRect(-15*size, 0*size, 30*size, 10*size);
        ctx.strokeRect(-6*size, -10*size, 12*size, 20*size);
        
        // Add bright accent lines
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 1*size;
        ctx.beginPath();
        ctx.moveTo(-20*size, 12*size);
        ctx.lineTo(20*size, 12*size);
        ctx.stroke();
        
        // Position indicator dot
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.arc(0, 0, 3*size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      rect(){ return {x:this.x-20, y:this.y-8, w:40, h:22}; }
    }


    class Invader{ 
      constructor(x,y,row){ 
        this.x=x; this.y=y; this.w=30; this.h=22; this.row=row; this.alive=true; this.anim=0; 
        this.value= [30,30,20,20,10][row] || 10;
        this.type = 'normal';
        this.zigzagOffset = 0;
        this.speedMultiplier = 1;
        this.legPhase = Math.random() * Math.PI * 2; // Random starting phase for crab walking
        
        // Special invader types for higher levels
        if(level >= 3 && Math.random() < 0.15){
          this.type = 'zigzag';
          this.value *= 2;
        } else if(level >= 5 && Math.random() < 0.1){
          this.type = 'fast';
          this.speedMultiplier = 2;
          this.value *= 1.5;
        }
      }
      
      update(dt){
        if(!this.alive) return;
        this.anim += 0.08;
        this.legPhase += dt * 4; // Crab leg animation speed
        
        if(this.type === 'zigzag'){
          this.zigzagOffset += dt * 3;
          this.y += Math.sin(this.zigzagOffset) * 0.5;
        }
      }
      
      draw(){ 
        if(!this.alive) return; 
        ctx.save(); 
        ctx.translate(this.x, this.y); 
        const t=this.anim; 
        
        let color = ['#8aa0ff','#8aa0ff','#66e6ff','#66e6ff','#98ffcc'][this.row]||'#98ffcc';
        if(this.type === 'zigzag') color = '#ff9d42';
        if(this.type === 'fast') color = '#ff4242';
        
        ctx.fillStyle = color;
        const up = Math.sin(t)>0;
        const w=this.w, h=this.h;
        
        // Draw crab legs first (behind body)
        ctx.fillStyle = color;
        const legOffset = Math.sin(this.legPhase) * 2;
        const legHeight = 3;
        
        // Left legs
        for(let i = 0; i < 3; i++) {
          const legY = -h/2 + 6 + i * 4;
          const legX = -w/2 - 4 + (i % 2 === 0 ? legOffset : -legOffset);
          ctx.fillRect(legX, legY, 6, legHeight);
          ctx.fillRect(legX - 3, legY + legHeight, 8, 2); // Leg tip
        }
        
        // Right legs  
        for(let i = 0; i < 3; i++) {
          const legY = -h/2 + 6 + i * 4;
          const legX = w/2 - 2 + (i % 2 === 0 ? -legOffset : legOffset);
          ctx.fillRect(legX, legY, 6, legHeight);
          ctx.fillRect(legX - 3, legY + legHeight, 8, 2); // Leg tip
        }
        
        // Draw crab body
        ctx.fillRect(-w/2, -h/2, w, 6);
        ctx.fillRect(-w/2+ (up?4:2), -h/2+6, w-(up?8:4), 6);
        ctx.fillRect(-w/2+ (up?10:8), -h/2+12, w-(up?20:16), 6);
        
        // Draw crab eyes (stalks)
        ctx.fillStyle = '#ffffff';
        const eyeStalk1X = -w/3 + Math.sin(t * 0.7) * 1;
        const eyeStalk2X = w/3 + Math.sin(t * 0.9) * 1;
        const eyeY = -h/2 - 3;
        
        // Eye stalks
        ctx.fillRect(eyeStalk1X - 1, eyeY, 2, 4);
        ctx.fillRect(eyeStalk2X - 1, eyeY, 2, 4);
        
        // Eye balls
        ctx.fillStyle = '#000000';
        ctx.fillRect(eyeStalk1X - 1, eyeY - 1, 2, 2);
        ctx.fillRect(eyeStalk2X - 1, eyeY - 1, 2, 2);
        
        // Special type indicators
        if(this.type === 'zigzag'){
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(-2, -2, 4, 4);
        } else if(this.type === 'fast'){
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(-6, -4, 3, 2);
          ctx.fillRect(3, -4, 3, 2);
        }
        
        ctx.restore(); 
      }
      
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    class Shield{ 
      constructor(x,y){ 
        this.x=x; this.y=y; this.cell=8; this.cols=12; this.rows=6; 
        // Create inverted U shape - hollow in the middle bottom
        this.grid=Array.from({length:this.rows},()=>Array(this.cols).fill(0));
        
        // Build inverted U shape
        for(let r=0; r<this.rows; r++){
          for(let c=0; c<this.cols; c++){
            // Top part - full width
            if(r < 2) {
              this.grid[r][c] = 1; // Less HP for easier destruction
            }
            // Middle part - sides only
            else if(r < 4) {
              if(c < 3 || c > 8) {
                this.grid[r][c] = 1;
              }
            }
            // Bottom part - just the edges
            else {
              if(c < 2 || c > 9) {
                this.grid[r][c] = 1;
              }
            }
          }
        }
      }
      
      hit(px,py){ 
        const lx = Math.floor((px - (this.x - this.cols*this.cell/2))/this.cell); 
        const ly = Math.floor((py - (this.y - this.rows*this.cell/2))/this.cell); 
        if(lx<0||ly<0||lx>=this.cols||ly>=this.rows) return false; 
        if(this.grid[ly][lx]>0){ 
          this.grid[ly][lx]--; 
          return true; 
        } 
        return false; 
      }
      
      draw(){ 
        ctx.save(); 
        ctx.translate(this.x - this.cols*this.cell/2, this.y - this.rows*this.cell/2); 
        for(let r=0;r<this.rows;r++) {
          for(let c=0;c<this.cols;c++){ 
            const hp=this.grid[r][c]; 
            if(hp<=0) continue; 
            ctx.globalAlpha = hp===1 ? 1 : 0.7; // Only 1 HP now
            ctx.fillStyle='#7bffb9'; 
            ctx.fillRect(c*this.cell, r*this.cell, this.cell-1, this.cell-1);
          }
        } 
        ctx.globalAlpha=1; 
        ctx.restore(); 
      }
    }

    class UFO{ 
      constructor(){ 
        this.w=50; this.h=22; this.y=72; 
        this.x = Math.random()<0.5? -60 : W+60; 
        this.vx = this.x<0? rand(110,160) : -rand(110,160); 
        this.alive=true; 
        // Much higher points for UFO!
        this.points= choice([500, 1000, 1500, 3000]); 
        this.tremoloTimer = null;
        this.tremoloPlaying = false;
        this.glowPhase = 0;
        this.trailParticles = [];
      }
      
      update(dt){ 
        this.x += this.vx*dt; 
        this.glowPhase += dt * 3;
        
        // Create trail particles
        if(Math.random() < 0.3 && this.alive) {
          this.trailParticles.push({
            x: this.x + rand(-20, 20),
            y: this.y + rand(-10, 10),
            vx: -this.vx * 0.2 + rand(-20, 20),
            vy: rand(-10, 10),
            life: 1,
            color: choice(['#ff6d7a', '#ffaa00', '#ffff00'])
          });
        }
        
        // Update trail particles
        for(let i = this.trailParticles.length - 1; i >= 0; i--) {
          const p = this.trailParticles[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.life -= dt * 2;
          if(p.life <= 0) {
            this.trailParticles.splice(i, 1);
          }
        }
        
        // Play tremolo sound while UFO is on screen
        if(this.x > -50 && this.x < W+50 && !this.tremoloPlaying) {
          this.playTremolo();
          this.tremoloPlaying = true;
        }
        
        // Stop tremolo when UFO leaves screen
        if((this.x < -60 || this.x > W+60) && this.tremoloPlaying) {
          this.stopTremolo();
          this.tremoloPlaying = false;
        }
        
        if(this.x<-100||this.x>W+100) {
          this.alive=false;
          this.stopTremolo();
        }
      }
      
      playTremolo(){
        if(muted || audio.state !== 'running' || state === 'paused') return;
        
        const playTremoloNote = () => {
          if(!this.alive || this.x < -60 || this.x > W+60 || !this.tremoloPlaying || state === 'paused') {
            this.stopTremolo();
            return;
          }
          
          try {
            beep('sine', 1200 + Math.sin(Date.now() * 0.01) * 200, .06, .008);
            this.tremoloTimer = setTimeout(playTremoloNote, 100);
          } catch(e) {
            console.warn('UFO tremolo error:', e);
          }
        };
        
        playTremoloNote();
      }
      
      stopTremolo(){
        if(this.tremoloTimer) {
          clearTimeout(this.tremoloTimer);
          this.tremoloTimer = null;
        }
        this.tremoloPlaying = false;
      }
      
      draw(){ 
        if(!this.alive) return; 
        
        // Draw trail particles
        for(const p of this.trailParticles) {
          ctx.save();
          ctx.globalAlpha = p.life * 0.6;
          ctx.fillStyle = p.color;
          ctx.shadowBlur = 10;
          ctx.shadowColor = p.color;
          const size = 4 * p.life;
          ctx.fillRect(p.x - size/2, p.y - size/2, size, size);
          ctx.restore();
        }
        
        ctx.save(); 
        ctx.translate(this.x, this.y); 
        
        // Glowing aura effect
        const glowSize = 30 + Math.sin(this.glowPhase) * 10;
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
        gradient.addColorStop(0, 'rgba(255, 109, 122, 0.6)');
        gradient.addColorStop(0.5, 'rgba(255, 170, 0, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
        
        // UFO body with enhanced colors
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ff6d7a';
        ctx.fillStyle='#ff6d7a'; 
        ctx.fillRect(-24,-6,48,12); 
        ctx.fillRect(-16,-10,32,8); 
        
        // Cockpit with animation
        const cockpitGlow = Math.abs(Math.sin(this.glowPhase * 2));
        ctx.fillStyle=`rgba(255, 255, 255, ${0.8 + cockpitGlow * 0.2})`; 
        ctx.fillRect(-8,-10,16,4); 
        
        // Flashing lights
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ffeb5c';
        ctx.fillStyle='#ffeb5c'; 
        for(let i=-3;i<4;i++) {
          const lightBright = Math.sin(this.glowPhase * 4 + i) > 0 ? 1 : 0.3;
          ctx.globalAlpha = lightBright;
          ctx.fillRect(i*7-2,0,4,4); 
        }
        ctx.restore(); 
      }
      
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }
    
    // Boss class
    class Boss{
      constructor(){
        this.x = W/2;
        this.y = 100;
        this.w = 120;
        this.h = 60;
        this.hp = 20 + level * 2;
        this.maxHp = this.hp;
        this.alive = true;
        this.moveTimer = 0;
        this.targetX = W/2;
        this.fireTimer = 0;
        this.phase = 1;
      }
      
      update(dt){
        if(!this.alive) return;
        
        // Movement pattern
        this.moveTimer += dt;
        if(this.moveTimer > 2){
          this.targetX = rand(150, W-150);
          this.moveTimer = 0;
        }
        
        // Smooth movement to target
        const dx = this.targetX - this.x;
        this.x += dx * dt * 2;
        
        // Boss shooting
        this.fireTimer -= dt;
        if(this.fireTimer <= 0){
          // Fire pattern based on phase
          if(this.phase === 1){
            // Single powerful shot
            enemyBullets.push(new Bullet(this.x, this.y + 30, 250, 'enemy', 5, 15));
          } else if(this.phase === 2){
            // Triple shot
            for(let i = -1; i <= 1; i++){
              enemyBullets.push(new Bullet(this.x + i*30, this.y + 30, 280, 'enemy'));
            }
          } else {
            // Spread shot
            for(let i = -2; i <= 2; i++){
              const angle = i * 0.2;
              const vx = Math.sin(angle) * 200;
              const vy = Math.cos(angle) * 200 + 100;
              const b = new Bullet(this.x, this.y + 30, vy, 'enemy');
              b.vx = vx;
              enemyBullets.push(b);
            }
          }
          beep('sine', 150, .08, .02);
          this.fireTimer = clamp(1.5 - this.phase * 0.3, 0.5, 1.5);
        }
        
        // Phase change based on HP
        if(this.hp <= this.maxHp * 0.66 && this.phase === 1) this.phase = 2;
        if(this.hp <= this.maxHp * 0.33 && this.phase === 2) this.phase = 3;
      }
      
      draw(){
        if(!this.alive) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Boss body with phase-based color
        const color = this.phase === 1 ? '#ff4444' : 
                     this.phase === 2 ? '#ff8844' : '#ffaa44';
        ctx.fillStyle = color;
        
        // Main body
        ctx.fillRect(-60, -20, 120, 40);
        ctx.fillRect(-50, -30, 100, 60);
        ctx.fillRect(-40, -35, 80, 70);
        
        // Eyes
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-30, -10, 10, 10);
        ctx.fillRect(20, -10, 10, 10);
        
        // HP bar
        ctx.fillStyle = 'rgba(255,0,0,0.5)';
        ctx.fillRect(-60, -50, 120, 8);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(-60, -50, 120 * (this.hp / this.maxHp), 8);
        
        ctx.restore();
      }
      
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
      
      hit(){
        this.hp--;
        if(this.hp <= 0){
          this.alive = false;
          
          // Stop boss BGM
          stopBGM();
          
          // Play victory fanfare
          playVictoryFanfare();
          
          // Create epic multi-stage explosion sequence
          const explosionStages = [
            {delay: 0, x: 0, y: 0, count: 40, type: 'explosion', color: '#ff4444'},
            {delay: 100, x: -30, y: -20, count: 30, type: 'firework', color: '#ffaa00'},
            {delay: 200, x: 30, y: -20, count: 30, type: 'firework', color: '#ffff00'},
            {delay: 300, x: -40, y: 20, count: 35, type: 'sparkle', color: '#00ff00'},
            {delay: 400, x: 40, y: 20, count: 35, type: 'sparkle', color: '#00ffff'},
            {delay: 500, x: 0, y: 0, count: 50, type: 'explosion', color: '#ffffff'},
            {delay: 700, x: 0, y: -30, count: 40, type: 'firework', color: '#ff00ff'},
            {delay: 900, x: 0, y: 0, count: 60, type: 'explosion', color: '#ffaa00'},
            {delay: 1100, x: 0, y: 0, count: 80, type: 'sparkle', color: '#ffffff'},
          ];
          
          // Execute explosion stages
          explosionStages.forEach(stage => {
            setTimeout(() => {
              createExplosion(
                this.x + stage.x, 
                this.y + stage.y, 
                stage.color, 
                stage.count, 
                stage.type
              );
              
              // Add screen shake for each stage
              screenShake = Math.max(screenShake, 10 + stage.count / 10);
            }, stage.delay);
          });
          
          // Create expanding shockwave rings
          for(let ring = 0; ring < 5; ring++) {
            setTimeout(() => {
              const ringCount = 16;
              for(let i = 0; i < ringCount; i++) {
                const angle = (Math.PI * 2 * i) / ringCount;
                const speed = 300 + ring * 50;
                particles.push({
                  x: this.x,
                  y: this.y,
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed,
                  life: 3 - ring * 0.3,
                  color: ['#ff0000', '#ff6600', '#ffff00', '#00ff00', '#0099ff'][ring],
                  size: 10 - ring,
                  type: 'shockwave',
                  gravity: 0,
                  initialLife: 3 - ring * 0.3,
                  update(dt) {
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;
                    this.vx *= 0.98;
                    this.vy *= 0.98;
                    this.life -= dt * 0.5;
                  },
                  draw() {
                    if(this.life <= 0) return;
                    ctx.save();
                    const ratio = this.life / this.initialLife;
                    ctx.globalAlpha = ratio * 0.8;
                    
                    // Draw glowing ring particle
                    const size = this.size * (2 - ratio);
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner bright core
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = ratio;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                  }
                });
              }
            }, ring * 200);
          }
          
          // Big points with rainbow text
          score += 1000 * level;
          
          // Multiple floating texts at different positions
          const messages = [
            {text: '👑 BOSS DEFEATED! 👑', y: -40, delay: 0},
            {text: `+${1000 * level} POINTS!`, y: 0, delay: 300},
            {text: '🎊 VICTORY! 🎊', y: 40, delay: 600},
            {text: '⭐ PERFECT! ⭐', y: -60, delay: 900}
          ];
          
          messages.forEach(msg => {
            setTimeout(() => {
              floatingTexts.push(new FloatingText(msg.text, this.x, this.y + msg.y));
            }, msg.delay);
          });
          
          // Sustained screen shake
          let shakeIntensity = 25;
          const shakeInterval = setInterval(() => {
            screenShake = shakeIntensity;
            shakeIntensity *= 0.9;
            if(shakeIntensity < 1) {
              clearInterval(shakeInterval);
            }
          }, 100);
        }
      }
    }

    // Power-up class
    class PowerUp{
      constructor(x, y, type){
        this.x = x;
        this.y = y;
        this.w = 24;
        this.h = 24;
        this.type = type; // 'rapid', 'multi', 'shield'
        this.vy = 60;
        this.dead = false;
        this.pulse = 0;
      }
      update(dt){
        this.y += this.vy * dt;
        this.pulse += dt * 5;
        if(this.y > H + 30) this.dead = true;
      }
      draw(){
        ctx.save();
        ctx.translate(this.x, this.y);
        const scale = 1 + Math.sin(this.pulse) * 0.1;
        ctx.scale(scale, scale);
        
        // Draw power-up icon based on type
        if(this.type === 'rapid'){
          ctx.fillStyle = '#ff9d42';
          ctx.fillRect(-10, -4, 4, 8);
          ctx.fillRect(-2, -4, 4, 8);
          ctx.fillRect(6, -4, 4, 8);
        } else if(this.type === 'multi'){
          ctx.fillStyle = '#42c3ff';
          ctx.fillRect(-8, -8, 3, 16);
          ctx.fillRect(-1.5, -8, 3, 16);
          ctx.fillRect(5, -8, 3, 16);
        } else if(this.type === 'shield'){
          ctx.fillStyle = '#42ff88';
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.lineTo(-10, -3);
          ctx.lineTo(-10, 6);
          ctx.lineTo(0, 10);
          ctx.lineTo(10, 6);
          ctx.lineTo(10, -3);
          ctx.closePath();
          ctx.fill();
        }
        
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = ctx.fillStyle;
        ctx.fill();
        
        ctx.restore();
      }
      rect(){ return {x:this.x-this.w/2, y:this.y-this.h/2, w:this.w, h:this.h}; }
    }

    // ===== World containers =====
    let player; let invaders=[]; let bullets=[]; let enemyBullets=[]; let shields=[]; let ufo=null; let invDir=1; let invSpeed=32; let invStepDown=18; let fireTimer=0; let ufoTimer=rand(12,24);
    let powerUps = [];
    let powerUpTimer = rand(8, 15);
    let boss = null;
    // Special attack function removed

    function setupLevel(){
      invaders.length=0; bullets.length=0; enemyBullets.length=0; 
      // Stop UFO tremolo before clearing UFO
      if(ufo) ufo.stopTremolo();
      ufo=null; boss=null;
      // Reduced enemy count: 8x4 instead of 11x5 for more casual gameplay
      const cols=8, rows=4; const startX=180, gapX=64, startY=120, gapY=40;
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        invaders.push(new Invader(startX + c*gapX, startY + r*gapY, r));
      }
      invDir=1; invSpeed= 28 + (level-1)*4; // レベルで少し速く
      const y=H-140; shields=[ new Shield(W*0.2,y), new Shield(W*0.5,y), new Shield(W*0.8,y) ];
    }
    
    function setupBossLevel(){
      invaders.length=0; bullets.length=0; enemyBullets.length=0; 
      // Stop UFO tremolo before clearing UFO
      if(ufo) ufo.stopTremolo();
      ufo=null;
      boss = new Boss();
      // Fewer shields for boss battle
      const y=H-140; shields=[ new Shield(W*0.3,y), new Shield(W*0.7,y) ];
      floatingTexts.push(new FloatingText('BOSS BATTLE!', W/2, H/2));
    }

    function startDemo() {
      console.log('Starting demo play...');
      isDemo = true;
      demoTimer = 0;
      
      // Start game in demo mode
      state='playing'; 
      score=0; 
      level=1; 
      lives=3;
      combo = 0; 
      comboTimer = 0;
      waveTransition = false; 
      waveTransitionTimer = 0;
      
      player = new Player();
      setupLevel();
      updateHUD();
      hideAllPanels();
      
      // Start demo BGM at lower volume
      if(audio.state === 'running' && audioInitialized && !muted) {
        playBGM('main');
      }
    }
    
    function stopDemo() {
      console.log('Stopping demo play...');
      isDemo = false;
      state = 'title';
      demoTimer = 0;
      
      // Clear game state
      invaders.length = 0;
      bullets.length = 0;
      enemyBullets.length = 0;
      powerUps.length = 0;
      particles.length = 0;
      floatingTexts.length = 0;
      
      if(ufo) {
        ufo.stopTremolo();
        ufo = null;
      }
      if(boss) boss = null;
      
      // Stop music and show title
      stopBGM();
      hideAllPanels();
      titleScreen.classList.remove('hidden');
      updateHUD();
    }
    
    function startGame(){
      console.log('Starting game...');
      isDemo = false;
      demoTimer = 0;
      
      // Clear any existing timeouts first
      if(window.nextLevelTimeout) {
        clearTimeout(window.nextLevelTimeout);
        window.nextLevelTimeout = null;
      }
      
      state='playing'; score=0; level=1; lives=5; // More lives for casual play
      combo = 0; comboTimer = 0; // Reset combo
      waveTransition = false; waveTransitionTimer = 0; // Reset transition
      
      // Reset session stats
      sessionStats = {
        startTime: Date.now(),
        enemiesDestroyed: 0,
        enemiesKilled: 0, // backward compat
        maxCombo: 0,
        bossesDefeated: 0,
        powerUpsCollected: 0,
        highestLevel: 1
      };
      
      player = new Player(); setupLevel(); updateHUD(); hideAllPanels();
      
      // Audio should already be initialized by button press
      if(audio.state === 'running' && audioInitialized) {
        console.log('Audio ready for game');
      } else {
        console.log('Audio not ready, will initialize on first interaction');
      }
      
      stopBGM();
      setTimeout(() => {
        if(state === 'playing') playBGM('normal');
      }, 500);
    }

    function nextLevel(){ 
      level++;
      sessionStats.highestLevel = Math.max(sessionStats.highestLevel, level); 
      // Start wave transition
      waveTransition = true;
      waveTransitionTimer = 2.5;
      state = 'transition';
      
      // Check for boss level (every 5 levels)
      isBossLevel = (level % 5 === 0);
      
      // Clear any existing timeouts to prevent multiple calls
      if(window.nextLevelTimeout) clearTimeout(window.nextLevelTimeout);
      
      window.nextLevelTimeout = setTimeout(() => {
        // Additional safety check
        if(state !== 'transition') return;
        
        invSpeed += 6; 
        if(isBossLevel) {
          setupBossLevel();
          stopBGM();
          setTimeout(() => {
            if(state === 'playing') playBGM('boss');
          }, 500);
        } else {
          setupLevel();
          stopBGM();
          setTimeout(() => {
            if(state === 'playing') playBGM('normal');
          }, 500);
        }
        updateHUD();
        state = 'playing';
        waveTransition = false;
        window.nextLevelTimeout = null;
      }, 2500);
    }

    function restart(){ 
      state='title'; hideAllPanels(); titleScreen.classList.remove('hidden'); 
      stopBGM();
      // Clear any pending timeouts
      if(window.nextLevelTimeout) {
        clearTimeout(window.nextLevelTimeout);
        window.nextLevelTimeout = null;
      }
    }

    function gameOver(){
      // If demo mode, just return to title
      if(isDemo) {
        stopDemo();
        return;
      }
      
      state='gameover'; hiscore = Math.max(hiscore, score); localStorage.setItem('inv_hi', String(hiscore)); updateHUD();
      
      // Save session stats for teacher review
      const playTime = Math.floor((Date.now() - sessionStats.startTime) / 1000);
      console.log('🎮 Session Stats for Teacher Review:', {
        playTime: `${Math.floor(playTime/60)}m ${playTime%60}s`,
        score,
        highestLevel: sessionStats.highestLevel,
        enemiesDestroyed: sessionStats.enemiesDestroyed,
        powerUpsCollected: sessionStats.powerUpsCollected,
        bossesDefeated: sessionStats.bossesDefeated || 0
      });
      
      document.getElementById('final-score').textContent = String(score);
      document.getElementById('final-hiscore').textContent = String(hiscore);
      hideAllPanels(); overScreen.classList.remove('hidden');
      stopBGM();
      // Clear any pending timeouts
      if(window.nextLevelTimeout) {
        clearTimeout(window.nextLevelTimeout);
        window.nextLevelTimeout = null;
      }
    }

    function togglePause(){ 
      if(state==='playing'){ 
        state='paused'; 
        pausedScreen.classList.remove('hidden'); 
        stopBGM(); // Stop all background music during pause
        // Stop UFO tremolo if playing
        if(ufo) {
          ufo.stopTremolo();
        }
      } else if(state==='paused'){ 
        state='playing'; 
        pausedScreen.classList.add('hidden'); 
        // Resume BGM
        setTimeout(() => {
          if(state === 'playing') {
            if(boss) {
              playBGM('boss');
            } else {
              playBGM('normal');
            }
            // Resume UFO tremolo if UFO exists
            if(ufo && ufo.x > -50 && ufo.x < W+50) {
              ufo.tremoloPlaying = false; // Reset flag so it can restart
              ufo.playTremolo();
              ufo.tremoloPlaying = true;
            }
          }
        }, 100);
      } 
    }

    function hideAllPanels(){ titleScreen.classList.add('hidden'); overScreen.classList.add('hidden'); pausedScreen.classList.add('hidden'); }

    // ===== Collision & helpers =====
    function overlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    function bottomInvadersByColumn(){
      const byCol = new Map();
      for(const inv of invaders){ if(!inv.alive) continue; const col = Math.round((inv.x-180)/64); const prev = byCol.get(col); if(!prev || inv.y>prev.y) byCol.set(col, inv); }
      return Array.from(byCol.values());
    }

    // ===== Main Loop =====
    let last=0;
    function loop(ts){
      const now=ts||0; const dt = Math.min(0.033,(now - last)/1000||0); last=now; 
      
      // Update demo timer in title screen
      if(state === 'title' && !isDemo) {
        demoTimer += dt;
        if(demoTimer >= DEMO_START_DELAY) {
          startDemo();
        }
      }
      
      // Update game logic only when playing or in transition
      if(state==='playing'||state==='transition') update(dt); 
      draw(); 
      ctx.restore(); // Restore from screen shake
      requestAnimationFrame(loop);
    }

    function update(dt){
      // Demo auto-play logic
      if(isDemo && player) {
        // Simple AI for demo mode
        const nearestInvader = invaders
          .filter(i => i.alive)
          .sort((a, b) => Math.abs(a.x - player.x) - Math.abs(b.x - player.x))[0];
        
        if(nearestInvader) {
          // Move towards nearest invader
          const targetX = nearestInvader.x;
          const diff = targetX - player.x;
          
          // Clear movement keys
          keys.delete('ArrowLeft');
          keys.delete('ArrowRight');
          
          // Set movement based on target
          if(Math.abs(diff) > 10) {
            if(diff < 0) keys.add('ArrowLeft');
            else keys.add('ArrowRight');
          }
          
          // Auto-fire periodically
          if(Math.random() < 0.05) {
            keys.add('Space');
            setTimeout(() => keys.delete('Space'), 100);
          }
        }
        
        // Dodge bullets
        const dangerBullet = enemyBullets
          .filter(b => !b.dead && Math.abs(b.x - player.x) < 50 && b.y > player.y - 100)
          .sort((a, b) => b.y - a.y)[0];
        
        if(dangerBullet) {
          keys.delete('ArrowLeft');
          keys.delete('ArrowRight');
          // Dodge away from bullet
          if(dangerBullet.x < player.x && player.x < W - 40) {
            keys.add('ArrowRight');
          } else if(player.x > 40) {
            keys.add('ArrowLeft');
          }
        }
      }
      
      player.update(dt);
      
      // Combo timer
      if(comboTimer > 0){
        comboTimer -= dt;
        if(comboTimer <= 0){
          combo = 0;
        }
      }
      
      // Power-up spawning (more frequent for casual play)
      powerUpTimer -= dt;
      if(powerUpTimer <= 0 && Math.random() < 0.6){
        const types = ['rapid', 'multi', 'shield'];
        const type = choice(types);
        powerUps.push(new PowerUp(rand(50, W-50), -30, type));
        powerUpTimer = rand(6, 12); // More frequent spawning
      }
      
      // Update power-ups
      for(const p of powerUps) p.update(dt);

      // Boss update
      if(boss){
        boss.update(dt);
        if(!boss.alive && state === 'playing'){
          beep('sawtooth',600,.12,.03);
          // Stop UFO tremolo when level cleared
          if(ufo) ufo.stopTremolo();
          nextLevel();
          return;
        }
      } else {
        // Invader marching
        const alive = invaders.filter(i=>i.alive);
        if(alive.length===0 && state === 'playing'){ 
          beep('sawtooth',600,.12,.03);
          // Stop UFO tremolo when level cleared
          if(ufo) ufo.stopTremolo();
          nextLevel(); 
          return; 
        }
      }

      if(!boss){
        // bounds of alive invaders
        const alive = invaders.filter(i=>i.alive);
        let minX=Infinity, maxX=-Infinity, maxY=-Infinity;
        for(const i of alive){ if(i.x<minX) minX=i.x; if(i.x>maxX) maxX=i.x; if(i.y>maxY) maxY=i.y; }
        const edgeLeft = (minX-30) <= 10;
        const edgeRight = (maxX+30) >= (W-10);
        if((edgeLeft && invDir<0) || (edgeRight && invDir>0)){ invDir*=-1; for(const i of alive){ i.y += invStepDown; } invSpeed += 6; beep('triangle',220,.05,.008); }
        for(const i of alive){ 
          i.update(dt);
          i.x += invDir * invSpeed * dt * i.speedMultiplier;
          
          // Check invader collision with shields - destroy shield blocks
          for(const sh of shields){
            const invRect = i.rect();
            // Check if invader overlaps shield area
            if(invRect.x < sh.x + sh.cols * sh.cell/2 &&
               invRect.x + invRect.w > sh.x - sh.cols * sh.cell/2 &&
               invRect.y < sh.y + sh.rows * sh.cell/2 &&
               invRect.y + invRect.h > sh.y - sh.rows * sh.cell/2){
              // Clear overlapping shield cells
              for(let r = 0; r < sh.rows; r++){
                for(let c = 0; c < sh.cols; c++){
                  const cellX = sh.x - sh.cols * sh.cell/2 + c * sh.cell;
                  const cellY = sh.y - sh.rows * sh.cell/2 + r * sh.cell;
                  if(cellX < invRect.x + invRect.w &&
                     cellX + sh.cell > invRect.x &&
                     cellY < invRect.y + invRect.h &&
                     cellY + sh.cell > invRect.y){
                    sh.grid[r][c] = 0; // Destroy shield cell
                  }
                }
              }
            }
          }
        }

        // Enemy fire
        fireTimer -= dt;
        if(fireTimer<=0){
          const bottoms = bottomInvadersByColumn();
          if(bottoms.length){ const shooter = choice(bottoms); enemyBullets.push(new Bullet(shooter.x, shooter.y+16, rand(160,220), 'enemy')); beep('sine', 220, .05, .01); }
          fireTimer = clamp(1.1 - level*0.05, 0.3, 1.1);
        }
        
        // Lose when invaders reach player line
        if(maxY >= player.y - 10){ 
          // Final explosion when invaders reach player
          createExplosion(player.x, player.y, '#ff4444', 30);
          floatingTexts.push(new FloatingText('OVERRUN!', W/2, H/2));
          gameOver(); 
        }
      }

      // UFO spawn (not during boss battles)
      if(!boss){
        ufoTimer -= dt; 
        if(ufoTimer<=0 && !ufo){ 
          ufo = new UFO(); 
          // UFO now plays tremolo sound automatically
          ufoTimer = rand(16, 28); 
        }
        if(ufo){ 
          ufo.update(dt); 
          if(!ufo.alive) ufo=null; 
        }
      }

      // Bullets
      for(const b of bullets) b.update(dt);
      for(const b of enemyBullets) b.update(dt);

      // Player bullets vs invaders/UFO/shields
      for(const b of bullets){ if(b.dead) continue; const br=b.rect();
        for(const inv of invaders){ if(!inv.alive) continue; if(overlap(br, inv.rect())){ 
          inv.alive=false; b.dead=true; 
          
          // Combo system
          combo++;
          sessionStats.enemiesDestroyed++;
          comboTimer = 2.5; // 2.5 seconds to maintain combo (more forgiving)
          const comboMultiplier = Math.min(combo, 10);
          const points = inv.value * comboMultiplier;
          score += points;
          updateHUD();
          checkAllAchievements();
          
          // Show combo feedback with enhanced effects
          if(combo > 1){
            const comboText = combo >= 10 ? `🔥 MAX COMBO x${comboMultiplier}! 🔥` : `⚡ x${comboMultiplier} COMBO ⚡`;
            floatingTexts.push(new FloatingText(comboText, inv.x, inv.y - 20));
            floatingTexts.push(new FloatingText(`+${points}`, inv.x, inv.y));
            
            // Enhanced multi-tone sound for combos
            const pitch = 300 + combo * 50;
            beep('square', Math.min(pitch, 800), .08, .02);
            setTimeout(() => beep('sine', Math.min(pitch + 200, 1000), .06, .01), 50);
            if(combo >= 5) {
              setTimeout(() => beep('triangle', Math.min(pitch + 400, 1200), .05, .01), 100);
            }
            if(combo >= 10) {
              // Super combo sound!
              setTimeout(() => beep('sawtooth', 1500, .1, .03), 150);
            }
          } else {
            beep('square', 300, .06, .02);
          }
          
          // Create massive explosion for invader with multiple particle types
          const colors = ['#8aa0ff','#8aa0ff','#66e6ff','#66e6ff','#98ffcc'];
          const baseColor = colors[inv.row] || '#98ffcc';
          
          // Main explosion
          createExplosion(inv.x, inv.y, baseColor, 20 + combo * 3, 'explosion');
          
          // Add sparkles
          if(combo > 3){
            createExplosion(inv.x, inv.y, '#ffff00', 10 + combo, 'sparkle');
          }
          
          // Add fireworks for high combos
          if(combo >= 7){
            createExplosion(inv.x, inv.y, '#ff00ff', 8, 'firework');
            createExplosion(inv.x, inv.y, '#00ffff', 8, 'firework');
          }
          
          // Screen shake for big combos
          if(combo >= 5){
            screenShake = Math.min(combo * 2, 20);
          }
          break; 
        }}
        if(!b.dead){ for(const sh of shields){ if(sh.hit(b.x, b.y)){ b.dead=true; break; } } }
        if(!b.dead && ufo){ if(overlap(br, ufo.rect())){ 
          combo = 0; // UFO resets combo but gives big points
          score+=ufo.points; updateHUD(); 
          
          // Giant floating text for UFO with emojis
          floatingTexts.push(new FloatingText(`🛸 UFO DESTROYED! +${ufo.points} 🛸`, ufo.x, ufo.y-20)); 
          
          ufo.stopTremolo(); // Stop tremolo sound when destroyed
          ufo.alive=false; b.dead=true; 
          
          // Epic UFO destruction sound - multi-layered
          beep('square', 1200, .1, .04);
          beep('sine', 1800, .08, .03);
          setTimeout(() => {
            beep('square', 900, .1, .04);
            beep('triangle', 1350, .08, .03);
          }, 80);
          setTimeout(() => {
            beep('square', 600, .1, .04);
            beep('sine', 900, .08, .03);
          }, 160);
          setTimeout(() => {
            beep('sawtooth', 400, .15, .05);
            beep('square', 200, .12, .08);
          }, 240);
          
          // Massive multi-colored explosion for UFO
          createExplosion(ufo.x, ufo.y, '#ff6d7a', 30, 'explosion');
          createExplosion(ufo.x, ufo.y, '#ffaa00', 25, 'firework');
          createExplosion(ufo.x, ufo.y, '#ffff00', 20, 'sparkle');
          createExplosion(ufo.x, ufo.y, '#00ffff', 15, 'sparkle');
          
          // Screen shake for UFO destruction
          screenShake = 15;
          
          // Bonus particles in a circle
          for(let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 * i) / 8;
            const speed = 200;
            particles.push({
              x: ufo.x,
              y: ufo.y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 2,
              color: '#ffffff',
              size: 6,
              type: 'explosion',
              gravity: 0,
              initialLife: 2,
              update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.life -= dt;
              },
              draw() {
                if(this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.life / this.initialLife;
                ctx.fillStyle = this.color;
                const size = this.size * (this.life / this.initialLife);
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
                ctx.restore();
              }
            });
          }
        }}
        
        // Boss collision
        if(!b.dead && boss){ if(overlap(br, boss.rect())){ 
          boss.hit(); b.dead=true; 
          beep('square', 400, .08, .03);
          createExplosion(b.x, b.y, '#ff4444', 8);
          if(!boss.alive) {
            sessionStats.bossesDefeated++;
            checkAllAchievements();
          }
        }}
      }

      // Enemy bullets vs player/shields
      for(const b of enemyBullets){ if(b.dead) continue; const br=b.rect();
        for(const sh of shields){ if(sh.hit(b.x, b.y)){ b.dead=true; break; } }
        if(b.dead) continue;
        if(overlap(br, player.rect()) && player.invulnerable <= 0){ 
          b.dead=true; lives--; updateHUD(); 
          beep('triangle',120,.12,.02); 
          screenFlash(); 
          
          // Player hit particle explosion
          createExplosion(player.x, player.y, '#ff4444', 20);
          floatingTexts.push(new FloatingText('HIT!', player.x, player.y - 30));
          
          // Set invulnerability period
          player.invulnerable = 1.5;
          
          if(lives<=0) {
            // In boss levels, proceed to next level instead of game over
            if(isBossLevel) {
              // Show bonus stage failed message
              floatingTexts.push(new FloatingText('BONUS STAGE FAILED - PROCEEDING...', W/2, H/2));
              
              // Reset for next level
              lives = 3; // Give some lives back
              level++; // Move to next level
              isBossLevel = false; // Clear boss level flag
              
              // Start next level after a short delay
              waveTransition = true;
              waveTransitionTimer = 2.5;
              state = 'transition';
              
              setTimeout(() => {
                if(state === 'transition') {
                  setupLevel();
                  stopBGM();
                  setTimeout(() => {
                    if(state === 'playing') playBGM('main');
                  }, 100);
                  state = 'playing';
                  waveTransition = false;
                }
              }, 2500);
              
              return;
            } else {
              return gameOver();
            }
          }
          player.x=W/2; 
          enemyBullets = enemyBullets.filter(bb=>bb.y < player.y-40); 
        }
      }

      // Player vs power-ups
      for(const p of powerUps){
        if(p.dead) continue;
        if(overlap(p.rect(), player.rect())){
          p.dead = true;
          
          sessionStats.powerUpsCollected++;
          
          if(p.type === 'shield'){
            // Repair shields back to original U shape
            for(const sh of shields){
              for(let r = 0; r < sh.rows; r++){
                for(let c = 0; c < sh.cols; c++){
                  let shouldHaveBlock = false;
                  
                  // Recreate U shape logic
                  if(r < 2) {
                    shouldHaveBlock = true;
                  } else if(r < 4) {
                    if(c < 3 || c > 8) shouldHaveBlock = true;
                  } else {
                    if(c < 2 || c > 9) shouldHaveBlock = true;
                  }
                  
                  if(shouldHaveBlock && sh.grid[r][c] === 0) {
                    sh.grid[r][c] = 1; // Restore blocks
                  }
                }
              }
            }
            floatingTexts.push(new FloatingText('SHIELDS REPAIRED!', player.x, player.y - 40));
            // Special power-up sound - ascending notes
            beep('sawtooth', 600, .08, .03);
            setTimeout(() => beep('sawtooth', 800, .08, .03), 80);
            setTimeout(() => beep('sawtooth', 1000, .08, .03), 160);
          } else {
            player.powerUp = p.type;
            player.powerUpTime = 8; // 8 seconds duration
            const text = p.type === 'rapid' ? 'RAPID FIRE!' : 'MULTI-SHOT!';
            floatingTexts.push(new FloatingText(text, player.x, player.y - 40));
            // Power-up acquired sound - ascending notes
            beep('square', 400, .06, .025);
            setTimeout(() => beep('square', 600, .06, .025), 60);
            setTimeout(() => beep('square', 800, .08, .03), 120);
          }
          
          checkAllAchievements();
        }
      }
      
      bullets = bullets.filter(b=>!b.dead);
      enemyBullets = enemyBullets.filter(b=>!b.dead);
      powerUps = powerUps.filter(p=>!p.dead);

      // Floating texts
      for(const ft of floatingTexts) ft.update(dt);
      floatingTexts = floatingTexts.filter(t=>!t.dead);
      
      // Particles
      for(const p of particles) p.update(dt);
      particles = particles.filter(p => p.life > 0);
    }

    // Simple flash on damage
    let flashT=0; function screenFlash(){ flashT=0.18; }

    // Floating text
    class FloatingText{ constructor(text,x,y){ this.text=text; this.x=x; this.y=y; this.t=0; this.dead=false; }
      update(dt){ this.t+=dt; this.y-=30*dt; if(this.t>0.8) this.dead=true; }
      draw(){ ctx.globalAlpha = 1 - this.t/0.8; ctx.fillStyle='#fff2b3'; ctx.font='700 18px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha=1; }
    }
    let floatingTexts=[];

    // Particle system for explosions
    class Particle{
      constructor(x, y, color, type = 'normal'){
        this.x = x;
        this.y = y;
        this.type = type;
        
        if(type === 'explosion'){
          // Bigger, faster explosion particles
          this.vx = (Math.random() - 0.5) * 500;
          this.vy = (Math.random() - 0.5) * 500;
          this.size = Math.random() * 8 + 4;
          this.life = 1.5;
          this.gravity = 200;
        } else if(type === 'sparkle'){
          // Sparkly star particles
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 400 + 100;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.size = Math.random() * 6 + 2;
          this.life = 2;
          this.gravity = -50; // Float upward
          this.rotation = Math.random() * Math.PI * 2;
          this.rotSpeed = (Math.random() - 0.5) * 10;
        } else if(type === 'firework'){
          // Firework style burst
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 300 + 200;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed - 100;
          this.size = Math.random() * 5 + 3;
          this.life = 1.8;
          this.gravity = 150;
          this.trail = [];
        } else {
          // Normal particles
          this.vx = (Math.random() - 0.5) * 280;
          this.vy = (Math.random() - 0.5) * 280;
          this.size = Math.random() * 4 + 2;
          this.life = 1;
          this.gravity = 0;
        }
        
        this.color = color;
        this.initialLife = this.life;
      }
      
      update(dt){
        // Store trail for firework type
        if(this.type === 'firework' && this.trail){
          this.trail.push({x: this.x, y: this.y, life: this.life});
          if(this.trail.length > 10) this.trail.shift();
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        if(this.gravity){
          this.vy += this.gravity * dt;
        }
        
        if(this.type === 'sparkle'){
          this.rotation += this.rotSpeed * dt;
          this.vx *= 0.95;
          this.vy *= 0.95;
        } else {
          this.vx *= 0.98;
          this.vy *= 0.98;
        }
        
        this.life -= dt * (this.type === 'explosion' ? 3 : 2);
        if(this.life <= 0) this.life = 0;
      }
      
      draw(){
        if(this.life <= 0) return;
        ctx.save();
        
        const lifeRatio = this.life / this.initialLife;
        ctx.globalAlpha = lifeRatio;
        
        if(this.type === 'sparkle'){
          // Draw as star
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);
          ctx.fillStyle = this.color;
          const size = this.size * lifeRatio;
          
          // Draw 4-point star
          ctx.beginPath();
          ctx.moveTo(0, -size);
          ctx.lineTo(size/3, -size/3);
          ctx.lineTo(size, 0);
          ctx.lineTo(size/3, size/3);
          ctx.lineTo(0, size);
          ctx.lineTo(-size/3, size/3);
          ctx.lineTo(-size, 0);
          ctx.lineTo(-size/3, -size/3);
          ctx.closePath();
          ctx.fill();
          
          // Add glow
          ctx.shadowBlur = 20;
          ctx.shadowColor = this.color;
          ctx.fill();
        } else if(this.type === 'firework'){
          // Draw with trail
          if(this.trail){
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.size * lifeRatio;
            ctx.beginPath();
            for(let i = 0; i < this.trail.length; i++){
              const t = this.trail[i];
              if(i === 0) ctx.moveTo(t.x, t.y);
              else ctx.lineTo(t.x, t.y);
            }
            ctx.lineTo(this.x, this.y);
            ctx.stroke();
          }
          
          // Draw head
          ctx.fillStyle = this.color;
          const size = this.size * lifeRatio * 1.5;
          ctx.shadowBlur = 15;
          ctx.shadowColor = this.color;
          ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
        } else {
          // Normal/explosion particles
          ctx.fillStyle = this.color;
          const size = this.size * lifeRatio;
          ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
          
          // Enhanced glow effect
          ctx.shadowBlur = this.type === 'explosion' ? 25 : 10;
          ctx.shadowColor = this.color;
          ctx.fillRect(this.x - size/4, this.y - size/4, size/2, size/2);
        }
        
        ctx.restore();
      }
    }
    
    let particles = [];
    
    let screenShake = 0;
    
    function createExplosion(x, y, color, count = null, type = 'normal'){
      // Use mobile-optimized particle count if not specified
      if(count === null) count = PARTICLE_COUNT;
      
      // Limit particles on mobile for performance
      if(particles.length > MAX_PARTICLES) particles.splice(0, 50);
      
      for(let i = 0; i < count; i++){
        particles.push(new Particle(x, y, color, type));
      }
    }

    function draw(){
      // Apply screen shake
      ctx.save();
      if(screenShake > 0){
        const shakeX = (Math.random() - 0.5) * screenShake;
        const shakeY = (Math.random() - 0.5) * screenShake;
        ctx.translate(shakeX, shakeY);
        screenShake *= 0.9; // Decay shake
        if(screenShake < 0.1) screenShake = 0;
      }
      
      // Clear entire canvas with dark blue background
      ctx.fillStyle = '#0b0f1a';
      ctx.fillRect(0, 0, W, H);
      
      // Always draw stars for visual feedback
      drawStars();
      
      // Debug info for mobile
      if(window.innerWidth <= 768) {
        ctx.fillStyle = '#ffffff';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`State: ${state}`, 10, 25);
        ctx.fillText(`Player: ${player ? 'YES' : 'NO'}`, 10, 40);
        ctx.fillText(`Audio: ${audioInitialized ? '🔊' : '🔇'}`, 10, 55);
        ctx.fillText(`Invaders: ${invaders.length}`, 10, 70);
      }
      
      // Show demo mode indicator
      if(isDemo) {
        ctx.save();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = 'bold 24px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('DEMO PLAY', W/2, 40);
        ctx.font = '16px monospace';
        ctx.fillText('Press any key to return to title', W/2, 65);
        ctx.restore();
      }
      
      // Draw shields first (background)
      for(const sh of shields) {
        if(sh) sh.draw();
      }
      
      // Draw power-ups
      for(const p of powerUps) {
        if(p && !p.dead) p.draw();
      }
      
      // Draw player with force visibility
      if(player) {
        player.draw();
        // Draw a bright circle around player for debugging
        if(window.innerWidth <= 768) {
          ctx.strokeStyle = '#ff00ff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(player.x, player.y, 50, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      
      // Draw invaders
      let aliveInvaders = 0;
      for(const i of invaders) {
        if(i && i.alive) {
          i.draw();
          aliveInvaders++;
        }
      }
      
      // Draw bullets
      for(const b of bullets) {
        if(b && !b.dead) b.draw();
      }
      
      for(const b of enemyBullets) {
        if(b && !b.dead) b.draw();
      }
      
      // Draw UFO and boss
      if(ufo && ufo.alive) ufo.draw();
      if(boss && boss.alive) boss.draw();
      
      // Draw particles and text on top
      for(const p of particles) {
        if(p && p.life > 0) p.draw();
      }
      
      for(const ft of floatingTexts) {
        if(ft && !ft.dead) ft.draw();
      }
      
      // Mobile debug info continued
      if(window.innerWidth <= 768) {
        ctx.fillStyle = '#ffff00';
        ctx.fillText(`Alive Invaders: ${aliveInvaders}`, 10, 110);
        ctx.fillText(`Bullets: ${bullets.length}`, 10, 130);
      }
      
      // Wave transition effect
      if(waveTransition){
        const progress = 1 - (waveTransitionTimer / 2.5);
        ctx.save();
        ctx.fillStyle = `rgba(11,15,26,${0.8 * Math.sin(progress * Math.PI)})`;
        ctx.fillRect(0, 0, W, H);
        
        // Wave text
        ctx.fillStyle = '#42ff88';
        ctx.font = 'bold 48px ui-sans-serif, system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if(isBossLevel){
          ctx.fillStyle = '#ff4444';
          ctx.fillText(`LEVEL ${level}`, W/2, H/2 - 40);
          ctx.fillText('BOSS BATTLE!', W/2, H/2 + 20);
        } else {
          ctx.fillText(`WAVE ${level}`, W/2, H/2);
        }
        
        ctx.restore();
        waveTransitionTimer -= 0.016;
      }
      
      if(flashT>0){ ctx.fillStyle='rgba(255,255,255,'+flashT.toFixed(2)+')'; ctx.fillRect(0,0,W,H); flashT-=0.016; }
    }

    // Starfield backdrop - enhanced for mobile visibility
    const stars = Array.from({length:130},()=>({x:Math.random()*W, y:Math.random()*H, s: Math.random()*1.5+0.5}));
    function drawStars(){
      ctx.save();
      for(const st of stars){ 
        st.y += st.s * 0.4; 
        if(st.y > H) st.y = 0; 
        
        // Brighter, larger stars for mobile
        const size = window.innerWidth <= 768 ? 3 : 2;
        ctx.globalAlpha = clamp(0.7 + st.s/2, 0.7, 1); 
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(st.x, st.y, size, size); 
      }
      ctx.globalAlpha = 1; 
      ctx.restore();
    }

    // --- Self-tests (run once on load; see console) ---
    function runSelfTests(){
      const results=[]; let passed=0; const assert=(name, cond)=>{ console.assert(cond, 'FAIL:', name); if(cond){passed++; results.push('✔ '+name);} else { results.push('✖ '+name);} };
      try{
        // Test 1: Shield.draw doesn't throw (typo regression)
        const sh = new Shield(100,100);
        try{ sh.draw(); assert('Shield.draw executes without ReferenceError', true); }catch(e){ assert('Shield.draw executes without ReferenceError', false); console.error(e); }

        // Test 2: Shield.hit depletes correctly (2 → 1 → 0)
        const px=sh.x, py=sh.y;
        const hit1=sh.hit(px,py); const hit2=sh.hit(px,py); const hit3=sh.hit(px,py);
        assert('Shield.hit returns true, true, then false', hit1 && hit2 && !hit3);

        // Test 3: Removed - Special attack feature deleted

        // Test 4: Game over when invader reaches player line
        state='playing'; player=new Player(); invaders=[new Invader(200, player.y-20, 0)]; shields=[]; bullets=[]; enemyBullets=[];
        update(0); assert('Invaders above player line do NOT end game', state==='playing');
        invaders[0].y = player.y - 5; update(0); assert('Invaders reaching player line DO end game', state==='gameover');
        state='title';
      }catch(e){ console.error('Self-tests crashed', e); }
      console.groupCollapsed('Invaders self-tests'); results.forEach(r=>console.log(r)); console.log(`${passed}/${results.length} tests passed`); console.groupEnd();
    }

    // Ensure DOM is loaded and initialize buttons
    function initializeButtons() {
      const btnStart = document.getElementById('btn-start');
      const btnRestart = document.getElementById('btn-restart');
      const btnTutorial = document.getElementById('btn-tutorial');
      const btnTutorialClose = document.getElementById('btn-tutorial-close');
      
      if (btnStart) {
        const startGameWithAudio = (e) => {
          e.preventDefault();
          console.log('Start button pressed');
          
          // Initialize audio on game start (iOS requirement)
          initializeAudio().then(() => {
            startGame();
          }).catch(() => {
            // Start game anyway if audio fails
            startGame();
          });
        };
        
        btnStart.addEventListener('click', startGameWithAudio);
        btnStart.addEventListener('touchstart', startGameWithAudio);
      }
      
      if (btnRestart) {
        btnRestart.addEventListener('click', (e) => {
          e.preventDefault();
          restart(); 
          startGame();
        });
      }
      
      if (btnTutorial) {
        btnTutorial.addEventListener('click', (e) => {
          e.preventDefault();
          document.getElementById('screen-title').classList.add('hidden');
          document.getElementById('screen-tutorial').classList.remove('hidden');
        });
      }
      
      if (btnTutorialClose) {
        btnTutorialClose.addEventListener('click', (e) => {
          e.preventDefault();
          document.getElementById('screen-tutorial').classList.add('hidden');
          document.getElementById('screen-title').classList.remove('hidden');
        });
      }
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeButtons);
    } else {
      initializeButtons();
    }

    // Prevent page scroll on space/arrow
    window.addEventListener('keydown', e=>{ if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); }, {passive:false});

    // Debug helpers
    window.__invaders__ = { mute(v){ muted=!!v; }, resetHi(){ localStorage.removeItem('inv_hi'); hiscore=0; updateHUD(); } };

    updateHUD();

    // Initialize demo timer
    demoTimer = 0;
    
    // Run tests, then start loop
    runSelfTests();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
